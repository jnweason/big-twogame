<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<title>å¤§è€äºŒ â€“ è·æ¥­è³­å ´ç‰ˆ (Pro)</title>

<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700;900&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.7.0/dist/confetti.browser.min.js"></script>

<style>
    :root{
        --human-card-w: 88px;
        --human-card-h: 123px;
        --human-gap: -50px;
        --ai-card-w: 50px;
        --ai-card-h: 70px;
        --ai-gap: -30px;
        --btm-bar-height: 45px;
        --neon-gold: #ffd700;
        --neon-red: #ff4444;
        --felt-green: #0d4a1c;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
    
    body {
        font-family: 'Rubik', sans-serif;
        background: #000;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        color: #fff;
    }

    #portrait-lock {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: #000; z-index: 9999;
        display: none; flex-direction: column;
        justify-content: center; align-items: center;
        text-align: center; color: #ffca28;
    }
    #portrait-lock span { font-size: 3rem; margin-bottom: 20px; display: block; animation: rotate 2s linear infinite; }
    @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    #portrait-lock p { font-size: 1.2rem; color: #fff; }

    @media screen and (orientation: portrait) {
        #portrait-lock { display: flex; }
        #game-wrapper { display: none !important; }
    }

    #game-wrapper {
        width: 100%; height: 100%;
        position: relative;
        background: 
            radial-gradient(circle at 30% 30%, rgba(255,255,255,0.05) 0%, transparent 50%),
            radial-gradient(circle at 70% 70%, rgba(0,0,0,0.3) 0%, transparent 50%),
            linear-gradient(135deg, #0d4a1c 0%, #083d16 100%);
        overflow: hidden;
        box-shadow: inset 0 0 150px rgba(0,0,0,0.5);
    }
    
    /* è³­æ¡Œé‚Šæ¡†èˆ‡è£é£¾ */
    #game-wrapper::before {
        content: "";
        position: absolute; top: 8%; left: 5%; right: 5%; bottom: 20%;
        border: 3px solid rgba(255,215,0,0.3);
        border-radius: 60px; 
        pointer-events: none;
        box-shadow: 
            0 0 30px rgba(255,215,0,0.1),
            inset 0 0 60px rgba(0,0,0,0.2);
    }
    
    /* ä¸­å¤®å€åŸŸè£é£¾ */
    .table-center {
        position: absolute; left: 50%; top: 42%;
        transform: translate(-50%, -50%);
        width: 400px; height: 200px;
        border: 2px dashed rgba(255,255,255,0.1);
        border-radius: 20px;
        pointer-events: none;
    }

    #bottom-bar {
        position: absolute; bottom: 0; left: 0; width: 100%;
        height: var(--btm-bar-height);
        background: linear-gradient(to top, #000, rgba(0,0,0,0.8));
        z-index: 500;
        display: flex; align-items: center; justify-content: space-between;
        padding: 0 25px;
        box-shadow: 0 -4px 20px rgba(0,0,0,0.6);
        border-top: 1px solid rgba(255,215,0,0.2);
        font-size: 1rem;
    }
    .bar-section { display: flex; align-items: center; gap: 15px; }
    .bar-label { color: #aaa; font-size: 0.85rem; margin-right: 5px; text-transform: uppercase; letter-spacing: 1px; }
    .bar-val { color: #fff; font-weight: bold; font-family: 'Courier New', monospace; font-size: 1.2rem; }
    .bar-money { color: var(--neon-gold); text-shadow: 0 0 10px rgba(255,215,0,0.4); }

    .player { position: absolute; z-index: 100; pointer-events: none; transition: all 0.3s ease; }
    .hand { display: flex; justify-content: center; align-items: center; position: relative; }

    .card {
        border-radius: 6px; background: #fff;
        box-shadow: 
            -2px 2px 8px rgba(0,0,0,0.4),
            0 0 0 1px rgba(0,0,0,0.1);
        position: relative; flex-shrink: 0;
        transition: transform 0.2s, margin 0.2s, box-shadow 0.2s, z-index 0s;
        overflow: hidden;
    }
    .card::before {
        content: ""; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, transparent 50%);
        pointer-events: none;
    }
    .card img { width: 100%; height: 100%; object-fit: contain; border-radius: 6px; display: block; }

    /* ========== ä¿®æ­£1ï¼šé¸ç‰Œå‘ä¸‹æ²‰ï¼Œä¸é®æ“‹æœªé¸ç‰Œ ========== */
    #player-0 {
        bottom: var(--btm-bar-height);
        left: 0; width: 100%;
        height: auto;
        padding-bottom: 10px;
        z-index: 200;
        pointer-events: auto;
    }
    #player-0 .hand {
        height: var(--human-card-h);
        margin: 0 auto;
        width: 100%;
        max-width: 1000px;
        padding: 0 20px;
        padding-top: 30px; /* æ”¹ç‚ºä¸Šæ–¹é ç•™ç©ºé–“ */
        
    }
    #player-0 .card {
        width: var(--human-card-w); height: var(--human-card-h);
        margin-left: var(--human-gap);
        cursor: pointer;
        transform-origin: bottom center;
        position: relative;
    }
    #player-0 .card:first-child { margin-left: 0; }
    
    /* æœªé¸ä¸­çš„ç‰Œï¼šå‰æ–¹ï¼Œz-indexè¼ƒé«˜ */
    #player-0 .card:not(.selected) {
    z-index: 10; /* æ˜ç¢ºè¨­ç½®æ¯” selected é«˜ */
    }
    
    /* é¸ä¸­çš„ç‰Œå‘ä¸‹æ²‰ï¼Œz-indexé™ä½ï¼Œé¿å…é®æ“‹å…¶ä»–ç‰Œ */
    #player-0 .card.selected {
        transform: translateY(-25px) scale(1.05); /* æ”¹ç‚ºå¾€ä¸Šï¼ˆè² å€¼ï¼‰ï¼ŒåŸæœ¬æ˜¯ 20pxï¼ˆå¾€ä¸‹ï¼‰ */
        border: 3px solid var(--neon-gold);
        box-shadow: 
            0 0 15px rgba(255,215,0,0.5),
            0 5px 15px rgba(0,0,0,0.3);
    z-index: 1 !important; /* ç¶­æŒåœ¨å¾Œæ–¹/ä¸‹æ–¹å±¤ç´šï¼Œè¢«æœªé¸ç‰Œè“‹ä½ */
    /* ç§»é™¤ opacity å’Œ filter è®Šæš—æ•ˆæœï¼Œä¿æŒäº®åº¦ */
    opacity: 1;
    filter: none;
    }
    
    /* æ‡¸åœæ•ˆæœï¼šå¾€ä¸Šæµ®ï¼Œä½†ä¿æŒåœ¨å¾Œæ–¹ï¼ˆz-indexè¼ƒä½ï¼‰ï¼Œé¿å…é®æ“‹æ—é‚Šçš„ç‰Œ */
    #player-0 .card:not(.selected):hover {
    transform: translateY(-20px) scale(1.05);
    z-index: 5; /* é™ä½z-indexï¼Œä½¿å…¶åœ¨æœªç§»å‹•çš„ç‰Œï¼ˆz-index:10ï¼‰å¾Œæ–¹ */
}
    
    #player-0.active::after {
        content: "YOUR TURN"; 
        position: absolute; 
        bottom: -40px; 
        left: 50%; 
        transform: translateX(-50%);
        background: var(--neon-gold); 
        color: #000; 
        padding: 5px 20px; 
        border-radius: 20px; 
        font-weight: 900; 
        font-size: 0.9rem;
        box-shadow: 0 0 20px rgba(255,215,0,0.6);
        animation: pulse 1.5s infinite;
        white-space: nowrap;
    }
    @keyframes pulse { 0%{transform: translateX(-50%) scale(1);} 50%{transform: translateX(-50%) scale(1.1);} 100%{transform: translateX(-50%) scale(1);} }

    /* AI ç©å®¶ä½ç½®èˆ‡æ¨£å¼ */
    #player-2 { top: 20px; left: 50%; transform: translateX(-50%); }
    #player-2 .hand { flex-direction: row; }
    #player-2 .hand .card { 
        width: var(--ai-card-w); height: var(--ai-card-h); margin-left: var(--ai-gap); 
        border-radius: 4px;
    }

    #player-3 { top: 50%; left: 10px; transform: translateY(-50%); }
    #player-3 .hand { flex-direction: column; align-items: flex-start; }
    #player-3 .hand .card { 
        width: var(--ai-card-h); height: var(--ai-card-w);
        margin-left: 0; margin-top: var(--ai-gap); 
        transform: rotate(90deg);
        border-radius: 4px;
    }

    #player-1 { top: 50%; right: 10px; transform: translateY(-50%); }
    #player-1 .hand { flex-direction: column; align-items: flex-end; }
    #player-1 .hand .card { 
        width: var(--ai-card-h); height: var(--ai-card-w);
        margin-left: 0; margin-top: var(--ai-gap); 
        transform: rotate(-90deg);
        border-radius: 4px;
    }

    .ai-info-tag {
        background: rgba(0,0,0,0.7); 
        padding: 5px 12px; 
        border-radius: 20px;
        color: #fff; 
        font-size: 0.8rem; 
        text-align: center; 
        margin-bottom: 8px;
        border: 1px solid rgba(255,255,255,0.2);
        backdrop-filter: blur(4px);
        font-weight: 500;
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    .player.active .ai-info-tag { 
        background: var(--neon-gold); 
        color: #000; 
        font-weight: bold; 
        border-color: var(--neon-gold);
        box-shadow: 0 0 15px rgba(255,215,0,0.5);
        animation: glow 1.5s infinite alternate;
    }
    @keyframes glow { from { box-shadow: 0 0 5px rgba(255,215,0,0.5); } to { box-shadow: 0 0 20px rgba(255,215,0,0.8); } }

    /* ========== ä¿®æ­£3ï¼šä¸­å¤®å‡ºç‰Œç·Šå¯†å †ç–Šï¼Œä¾åºè“‹ä½ ========== */
    #center-play {
        position: absolute; left: 50%; top: 42%;
        transform: translate(-50%, -50%);
        min-width: 350px; min-height: 140px;
        display: flex; justify-content: center; align-items: center;
        z-index: 50; 
        pointer-events: none;
        perspective: 1000px;
    }
    
    /* ç·Šå¯†å †ç–Šæ•ˆæœï¼šåªéœ²å‡ºå°‘é‡é‚Šç·£ï¼Œé¡ä¼¼çœŸå¯¦è“‹ç‰Œ */
    #center-play .card {
        width: 75px; 
        height: 105px; 
        margin-left: -68px; /* é«˜åº¦é‡ç–Šï¼Œåªéœ²å‡ºç´„7px */
        box-shadow: 2px 2px 8px rgba(0,0,0,0.4);
        border: 1px solid rgba(255,255,255,0.2);
        transition: all 0.3s ease;
    }
    
    /* ç¬¬ä¸€å¼µç‰Œä¸éœ€è¦è² margin */
    #center-play .card:first-child {
        margin-left: 0;
    }
    
    /* æœ€å¾Œä¸€å¼µç‰Œï¼ˆæœ€æ–°çš„ç‰Œï¼‰é™°å½±æ›´æ˜é¡¯ï¼Œè¡¨ç¤ºåœ¨æœ€ä¸Šå±¤ */
    #center-play .card:last-child {
        box-shadow: 3px 3px 12px rgba(0,0,0,0.5);
        border: 1px solid rgba(255,215,0,0.3);
    }
    
    @keyframes stackIn {
        from { 
            opacity: 0; 
            transform: translateY(-30px) scale(0.8); 
        }
        to { 
            opacity: 1; 
            transform: translateY(0) scale(1); 
        }
    }
    
    /* æ‡¸åœæ™‚ç¨å¾®å±•é–‹ä»¥ä¾¿æŸ¥çœ‹ï¼ˆå¯é¸åŠŸèƒ½ï¼‰ */
    #center-play:hover .card {
        margin-left: -45px;
        transition: margin-left 0.3s ease;
    }
    
    #controls-area {
        position: absolute;
        bottom: calc(var(--human-card-h) + var(--btm-bar-height) + 25px);
        left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center; gap: 12px;
        z-index: 300; pointer-events: none;
        width: 100%;
    }

    .btn-group-main { display: flex; gap: 25px; pointer-events: auto; }
    
    button.action-btn {
        padding: 12px 35px; border-radius: 50px; border: none;
        font-weight: 900; font-size: 1.1rem; color: #fff;
        box-shadow: 
            0 5px 0 rgba(0,0,0,0.3),
            0 5px 15px rgba(0,0,0,0.3);
        transition: all 0.1s; cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    button.action-btn:active { 
        transform: translateY(3px); 
        box-shadow: 
            0 2px 0 rgba(0,0,0,0.3),
            0 2px 10px rgba(0,0,0,0.3);
    }
    button.btn-play { 
        background: linear-gradient(to bottom, #00c853, #009624); 
        border: 2px solid #00e676;
    }
    button.btn-pass { 
        background: linear-gradient(to bottom, #ff5252, #c50e0e); 
        border: 2px solid #ff867c;
    }
    button:disabled { 
        filter: grayscale(1) brightness(0.5); 
        opacity: 0.6; 
        cursor: not-allowed;
        transform: none !important;
        box-shadow: none !important;
    }

    .smart-group {
        display: flex; gap: 8px;
        background: rgba(0,0,0,0.6); 
        padding: 8px 15px; 
        border-radius: 25px;
        pointer-events: auto; 
        opacity: 0; 
        transition: opacity 0.3s, transform 0.3s;
        border: 1px solid rgba(255,255,255,0.1);
        backdrop-filter: blur(5px);
    }
    #player-0.active ~ #controls-area .smart-group { opacity: 1; transform: translateY(0); }

    button.smart-btn {
        background: rgba(255,255,255,0.1); 
        border: 1px solid rgba(255,255,255,0.3); 
        color: #fff;
        padding: 6px 12px; 
        font-size: 0.8rem; 
        border-radius: 15px; 
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s;
    }
    button.smart-btn:hover { 
        background: rgba(255,255,255,0.25); 
        transform: translateY(-2px);
    }
    button.smart-btn.active-hint {
        background: var(--neon-gold); 
        color: #000; 
        border-color: var(--neon-gold);
        font-weight: bold; 
        box-shadow: 0 0 15px rgba(255,215,0,0.6);
        animation: hintPulse 1s infinite alternate;
    }
    @keyframes hintPulse { from { box-shadow: 0 0 5px rgba(255,215,0,0.6); } to { box-shadow: 0 0 20px rgba(255,215,0,0.9); } }

    #modal-overlay {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.9); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
        backdrop-filter: blur(10px);
    }
    .modal-box {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        padding: 40px; 
        border-radius: 20px; 
        text-align: center;
        border: 3px solid var(--neon-gold);
        width: 450px; 
        max-width: 90%;
        box-shadow: 0 0 50px rgba(255,215,0,0.2), inset 0 0 60px rgba(0,0,0,0.5);
    }
    .modal-box h2 {
        color: var(--neon-gold);
        text-shadow: 0 0 20px rgba(255,215,0,0.5);
        font-size: 2rem;
        margin-bottom: 20px;
    }
    .stake-btn {
        margin: 8px; 
        padding: 12px 25px; 
        background: rgba(255,255,255,0.1); 
        border: 2px solid rgba(255,255,255,0.3);
        color: #fff; 
        border-radius: 25px; 
        cursor: pointer;
        font-weight: 500;
        transition: all 0.3s;
        font-size: 1.1rem;
    }
    .stake-btn:hover { background: rgba(255,255,255,0.2); transform: scale(1.05); }
    .stake-btn.selected { 
        background: var(--neon-gold); 
        color: #000; 
        border-color: var(--neon-gold);
        box-shadow: 0 0 20px rgba(255,215,0,0.4);
    }
    
    .mode-btn {
        padding: 10px 25px; 
        margin: 10px 5px; 
        background: rgba(255,255,255,0.1); 
        border: 2px solid rgba(255,255,255,0.3); 
        color: #fff; 
        border-radius: 20px; 
        cursor: pointer; 
        font-weight: 500;
        transition: all 0.3s;
    }
    .mode-btn:hover { background: rgba(255,255,255,0.2); }
    .mode-btn.selected { 
        background: var(--neon-gold); 
        color: #000; 
        border-color: var(--neon-gold);
        box-shadow: 0 0 15px rgba(255,215,0,0.4);
    }
    
    #exchange-ui {
        position: absolute; bottom: calc(var(--human-card-h) + var(--btm-bar-height) + 100px);
        left: 50%; transform: translateX(-50%);
        display: none; flex-direction: column; align-items: center; gap: 15px;
        z-index: 400; pointer-events: auto;
    }
    #exchange-btn {
        padding: 15px 40px; 
        background: linear-gradient(to bottom, #00c853, #009624); 
        border: none; 
        border-radius: 50px; 
        color: white; 
        font-weight: 900;
        font-size: 1.2rem;
        cursor: pointer; 
        box-shadow: 0 5px 0 rgba(0,0,0,0.3), 0 5px 20px rgba(0,200,83,0.4);
        text-transform: uppercase;
        letter-spacing: 2px;
    }
    #exchange-btn:active { 
        transform: translateY(3px); 
        box-shadow: 0 2px 0 rgba(0,0,0,0.3);
    }
    
    .msg-pop {
        position: absolute; 
        font-size: 2.2rem; 
        font-weight: 900;
        text-shadow: 0 3px 6px rgba(0,0,0,0.8);
        pointer-events: none; 
        z-index: 600;
        animation: popUp 0.8s ease-out forwards;
        white-space: nowrap;
    }
    @keyframes popUp {
        0% { opacity: 0; transform: translateY(20px) scale(0.8); }
        20% { opacity: 1; transform: translateY(-20px) scale(1.2); }
        100% { opacity: 0; transform: translateY(-40px) scale(1); }
    }

    /* ç‰Œå‹ç‰¹æ•ˆæ¨™ç±¤ */
    .hand-type-tag {
        position: absolute;
        top: -30px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #ffd700, #ffaa00);
        color: #000;
        padding: 5px 15px;
        border-radius: 15px;
        font-weight: 900;
        font-size: 0.9rem;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        animation: tagPop 0.5s ease-out;
        white-space: nowrap;
        z-index: 100;
    }
    @keyframes tagPop {
        from { transform: translateX(-50%) scale(0) rotate(-10deg); opacity: 0; }
        to { transform: translateX(-50%) scale(1) rotate(0deg); opacity: 1; }
    }

    /* çµç®—ç•«é¢å¼·åŒ– */
    #round-summary {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.95); z-index: 3000;
        display: none; flex-direction: column; align-items: center; justify-content: center;
        color: #fff;
        backdrop-filter: blur(10px);
    }
    .summary-title {
        font-size: 3rem; 
        color: var(--neon-gold); 
        margin-bottom: 30px; 
        font-weight: 900;
        text-shadow: 0 0 30px rgba(255,215,0,0.6);
        animation: titleGlow 2s infinite alternate;
    }
    @keyframes titleGlow { from { text-shadow: 0 0 20px rgba(255,215,0,0.6); } to { text-shadow: 0 0 40px rgba(255,215,0,1); } }
    
    .summary-grid {
        display: grid; grid-template-columns: repeat(4, 1fr); gap: 25px;
        width: 95%; max-width: 1400px; margin-bottom: 40px;
    }
    .summary-player {
        background: rgba(255,255,255,0.05); 
        border: 2px solid rgba(255,255,255,0.1);
        border-radius: 20px; 
        padding: 20px; 
        text-align: center;
        backdrop-filter: blur(5px);
        transition: transform 0.3s;
    }
    .summary-player:hover { transform: translateY(-5px); }
    .summary-player.winner {
        border-color: var(--neon-gold); 
        background: rgba(255,215,0,0.1);
        box-shadow: 0 0 30px rgba(255,215,0,0.2);
    }
    .summary-player.loser {
        border-color: var(--neon-red); 
        background: rgba(255,68,68,0.05);
    }
    .summary-name { font-size: 1.4rem; font-weight: bold; margin-bottom: 15px; color: #fff; }
    .summary-chips { font-size: 2rem; font-family: 'Courier New', monospace; margin-bottom: 15px; font-weight: 900; }
    .summary-chips.positive { color: #00e676; text-shadow: 0 0 10px rgba(0,230,118,0.4); }
    .summary-chips.negative { color: #ff5252; text-shadow: 0 0 10px rgba(255,82,82,0.4); }
    .summary-cards {
        display: flex; flex-wrap: wrap; justify-content: center; gap: 3px;
        margin-top: 15px; min-height: 60px;
    }
    .summary-cards .card {
        width: 45px; height: 63px; margin: 0; border-radius: 4px;
    }
    .special-penalty {
        color: #ffaa00; 
        font-size: 1rem; 
        margin-top: 10px;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(255,170,0,0.3);
    }
    .continue-btn {
        padding: 18px 50px; 
        background: linear-gradient(135deg, #ffd700, #ffaa00); 
        color: #000;
        border: none; 
        border-radius: 50px; 
        font-weight: 900; 
        font-size: 1.3rem;
        cursor: pointer; 
        box-shadow: 0 5px 20px rgba(255,215,0,0.4);
        transition: all 0.3s;
        text-transform: uppercase;
        letter-spacing: 2px;
    }
    .continue-btn:hover { 
        transform: scale(1.05); 
        box-shadow: 0 8px 30px rgba(255,215,0,0.6);
    }

    /* é£›è¡Œä¸­çš„ç‰Œ */
    .flying-card {
        position: fixed;
        z-index: 9999;
        pointer-events: none;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        border-radius: 6px;
        overflow: hidden;
    }
    .flying-card img {
        width: 100%; height: 100%; object-fit: contain; display: block;
    }

    @media (max-width: 768px) {
        :root {
            --human-card-w: 55px; --human-card-h: 77px; --human-gap: -28px;
            --ai-card-w: 40px; --ai-card-h: 56px; --ai-gap: -22px;
        }
        #center-play { min-width: 280px; }
        #center-play .card { width: 50px; height: 70px; margin-left: -45px; }
        .ai-info-tag { font-size: 0.7rem; padding: 3px 8px; }
        .summary-grid { grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .summary-title { font-size: 2rem; }
        .modal-box { padding: 25px; }
    }
</style>
</head>
<body>

<div id="portrait-lock">
    <span>â†»</span>
    <p>ç‚ºäº†æœ€ä½³é«”é©—<br>è«‹å°‡æ‰‹æ©Ÿæ©«å‘æ—‹è½‰</p>
</div>

<div id="game-wrapper">
    <div class="table-center"></div>

    <div id="bottom-bar">
        <div class="bar-section">
            <span class="bar-label">ç±Œç¢¼</span>
            <span id="my-chips" class="bar-val bar-money">$10,000</span>
        </div>
        <div style="flex:1;"></div> 
        <div class="bar-section">
            <span class="bar-label">å‰©é¤˜</span>
            <span id="my-cnt" class="bar-val">0</span>
            <span class="bar-label" style="margin-left:4px;">å¼µ</span>
        </div>
    </div>
    
    <div id="modal-overlay">
        <div class="modal-box" id="start-screen">
            <h2>CASINO BIG TWO</h2>
            <p style="color:#aaa; margin-bottom:25px; font-size:1rem;">é¸æ“‡éŠæˆ²æ¨¡å¼èˆ‡åº•æ³¨</p>
            <div style="margin-bottom:20px;">
                <button id="mode-normal" class="mode-btn selected" onclick="selectGameMode('normal')">ä¸€èˆ¬å±€</button>
                <button id="mode-exchange" class="mode-btn" onclick="selectGameMode('exchange')">äº¤æ›å±€</button>
            </div>
            <div>
                <button class="stake-btn" onclick="startGame(50)">$50</button>
                <button class="stake-btn selected" onclick="startGame(100)">$100</button>
                <button class="stake-btn" onclick="startGame(200)">$200</button>
                <button class="stake-btn" onclick="startGame(500)">$500</button>
            </div>
        </div>
        
        <div class="modal-box" id="game-over-screen" style="display:none;">
            <h2 id="go-title" style="margin-bottom:20px; font-size:2.5rem;">GAME OVER</h2>
            <p id="go-msg" style="margin-bottom:30px; font-size:1.2rem; color:#ccc;"></p>
            <button class="stake-btn selected" onclick="location.reload()" style="padding:15px 40px; font-size:1.2rem;">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <div id="round-summary">
        <div class="summary-title">â™  å›åˆçµç®— â™£</div>
        <div class="summary-grid" id="summary-content"></div>
        <button class="continue-btn" onclick="closeRoundSummary()">ç¹¼çºŒéŠæˆ²</button>
    </div>

    <div id="center-play"></div>
    <div id="info-box" style="position:absolute; top:18%; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); padding:10px 25px; border-radius:30px; display:none; font-weight:bold; border:1px solid rgba(255,215,0,0.3); box-shadow:0 5px 20px rgba(0,0,0,0.5); z-index:400;">æç¤º</div>

    <div id="player-0" class="player active">
        <div class="hand" id="hand-0"></div>
    </div>
    
    <div id="exchange-ui">
        <button id="exchange-btn" onclick="performExchange()">ç¢ºèªäº¤æ›</button>
    </div>
    
    <div id="controls-area">
        <div class="btn-group-main">
            <button id="btn-pass" class="action-btn btn-pass" onclick="humanPass()">PASS</button>
            <button id="btn-play" class="action-btn btn-play" onclick="humanPlay()">å‡ºç‰Œ</button>
        </div>
        <div class="smart-group">
            <button id="smart-pair" class="smart-btn" onclick="autoSelect('pair')">å°å­</button>
            <button id="smart-straight" class="smart-btn" onclick="autoSelect('straight')">é †å­</button>
            <button id="smart-fullhouse" class="smart-btn" onclick="autoSelect('fullhouse')">è‘«è˜†</button>
            <button id="smart-fourkind" class="smart-btn" onclick="autoSelect('fourkind')">éµæ”¯</button>
            <button id="smart-straightflush" class="smart-btn" onclick="autoSelect('straightflush')">åŒèŠ±é †</button>
            <button class="smart-btn" onclick="clearSelection()" style="background:rgba(255,255,255,0.2);">æ¸…é™¤</button>
        </div>
    </div>

    <div id="player-1" class="player ai">
        <div class="ai-info-tag">AI 1<br><span id="chips-1">$10k</span> â€¢ <span id="cnt-1">0</span>å¼µ</div>
        <div class="hand" id="hand-1"></div>
    </div>
    
    <div id="player-2" class="player ai">
        <div class="ai-info-tag">AI 2<br><span id="chips-2">$10k</span> â€¢ <span id="cnt-2">0</span>å¼µ</div>
        <div class="hand" id="hand-2"></div>
    </div>
    
    <div id="player-3" class="player ai">
        <div class="ai-info-tag">AI 3<br><span id="chips-3">$10k</span> â€¢ <span id="cnt-3">0</span>å¼µ</div>
        <div class="hand" id="hand-3"></div>
    </div>
</div>

<script>
/* ================= å…¨å±€è®Šæ•¸ ================= */
const SUITS = ['C','D','H','S']; 
const SUIT_NAMES = ['â™£', 'â™¦', 'â™¥', 'â™ '];
const API_RANKS = {3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'0',11:'J',12:'Q',13:'K',14:'A',15:'2'};
const BACK_IMG = "https://deckofcardsapi.com/static/img/back.png";

// äº”å¼µç‰Œå‹ç­‰ç´šå®šç¾©ï¼ˆç”¨æ–¼å£“åˆ¶åˆ¤æ–·ï¼‰
const HAND_RANK = {
    'straight': 1,      // é †å­
    'fullhouse': 2,     // è‘«è˜†  
    'fourkind': 3,      // éµæ”¯
    'straightflush': 4  // åŒèŠ±é †
};

let players = [];
let currentTurn = 0;   
let lastPlay = null;   
let passCount = 0;     
let isRoundActive = false; 
let isFirstTurnOfGame = true;
let gameStake = 100;
let isGameRunning = false;
let gameMode = 'normal'; 
let exchangeCards = [];
let roundPassed = {};
let currentRoundMaxPlayer = 0;
let consecutivePassCount = 0;
let playedCardsHistory = [];
let currentRoundPlays = [];

/* ================= åˆå§‹åŒ– ================= */
function initPlayers() {
    players = Array(4).fill(0).map((_, i) => ({
        id: i,
        isHuman: i === 0,
        hand: [],
        chips: 10000,
        lastSearchIndex: 0
    }));
    playedCardsHistory = [];
    currentRoundPlays = [];
    updateInfoUI();
}

function selectGameMode(mode) {
    gameMode = mode;
    document.getElementById('mode-normal').classList.toggle('selected', mode === 'normal');
    document.getElementById('mode-exchange').classList.toggle('selected', mode === 'exchange');
}

function startGame(stake) {
    gameStake = stake;
    document.getElementById('modal-overlay').style.display = 'none';
    initPlayers();
    if (gameMode === 'exchange') {
        startExchangeRound();
    } else {
        startNewRound();
    }
}

function startExchangeRound() {
    let deck = createDeck();
    shuffle(deck);
    resetRoundState();
    players.forEach(p => { p.hand = []; p.lastSearchIndex = 0; });
    document.getElementById('center-play').innerHTML = '';
    for(let i=0; i<13; i++) {
        for(let p=0; p<4; p++) {
            players[p].hand.push(deck.pop());
        }
    }
    players.forEach(p => sortHand(p.hand));
    isRoundActive = false; 
    renderAllHands();
    updateInfoUI();
    document.getElementById('exchange-ui').style.display = 'flex';
    showMsg("é¸æ“‡0-3å¼µç‰Œæº–å‚™äº¤æ›", 3000);
}

function performExchange() {
    exchangeCards = [];
    for (let i = 0; i < 4; i++) {
        const player = players[i];
        let selectedCards = [];
        if (i === 0) {
            const selectedEls = document.querySelectorAll('#hand-0 .selected');
            selectedCards = Array.from(selectedEls).map(el => player.hand[parseInt(el.dataset.idx)]);
        } else {
            // AIæ™ºèƒ½é¸æ“‡äº¤æ›ç‰Œï¼ˆå‚¾å‘æ›æ‰å¤§ç‰Œæˆ–å­¤å¼µï¼‰
            const sortedHand = [...player.hand].sort((a,b) => b.rank - a.rank);
            const numToExchange = Math.floor(Math.random() * 3) + 1; // 1-3å¼µ
            selectedCards = sortedHand.slice(0, numToExchange);
        }
        exchangeCards.push({ playerId: i, cards: selectedCards });
    }
    const humanCards = exchangeCards[0].cards;
    if(humanCards.length > 3) {
        showMsg("è«‹é¸æ“‡0-3å¼µç‰Œ", 2000);
        return;
    }
    exchangeAnimation();
}

function exchangeAnimation() {
    document.getElementById('exchange-ui').style.display = 'none';
    showMsg("äº¤æ›ç‰Œä¸­...", 2000);
    const center = document.getElementById('center-play');
    center.innerHTML = '';
    let allExchangeCards = [];
    exchangeCards.forEach(exchange => {
        allExchangeCards = allExchangeCards.concat(exchange.cards);
    });
    
    // å‰µå»ºé£›è¡Œå‹•ç•«
    allExchangeCards.forEach((card, i) => {
        const div = document.createElement('div');
        div.className = 'card';
        div.style.zIndex = i;
        div.style.position = 'absolute';
        div.innerHTML = `<img src="${BACK_IMG}">`;
        center.appendChild(div);
        
        // éš¨æ©Ÿæ•£é–‹å¾Œé›†ä¸­åˆ°ä¸­å¤®
        gsap.fromTo(div, 
            { x: (Math.random()-0.5)*200, y: (Math.random()-0.5)*200, rotation: Math.random()*360 },
            { x: 0, y: 0, rotation: 0, duration: 0.8, delay: i*0.05, ease: "power2.out" }
        );
    });
    
    setTimeout(() => {
        // æ´—ç‰Œå‹•ç•«
        gsap.to('#center-play .card', {
            rotation: "+=360", 
            duration: 1, 
            ease: "power1.inOut", 
            repeat: 2,
            yoyo: true,
            onComplete: () => {
                // ========== ä¿®æ­£2ï¼šæ¸…ç©ºäº¤æ›ç‰Œï¼Œé¿å…å½±éŸ¿å¾ŒçºŒå‡ºç‰Œ ==========
                center.innerHTML = '';
                
                shuffle(allExchangeCards);
                let startIndex = 0;
                for (let i = 0; i < 4; i++) {
                    const numCards = exchangeCards[i].cards.length;
                    if (numCards > 0) {
                        const playerCards = allExchangeCards.slice(startIndex, startIndex + numCards);
                        startIndex += numCards;
                        players[i].hand = players[i].hand.filter(card => 
                            !exchangeCards[i].cards.some(exCard => exCard.val === card.val)
                        );
                        players[i].hand = players[i].hand.concat(playerCards);
                        sortHand(players[i].hand);
                    }
                }
                renderAllHands();
                updateInfoUI();
                setTimeout(() => {
                    startNewRoundWithExchange();
                }, 500);
            }
        });
    }, 1000);
}

function startNewRoundWithExchange() {
    if(players.some(p => p.chips <= 0)) {
        gameOver();
        return;
    }
    isGameRunning = true;
    resetRoundState();
    renderAllHands();
    updateInfoUI();
    if(checkDragon()) return; 
    determineFirstPlayer();
    checkTurn();
}

function startNewRound() {
    if(players.some(p => p.chips <= 0)) {
        gameOver();
        return;
    }
    isGameRunning = true;
    let deck = createDeck();
    shuffle(deck);
    players.forEach(p => { p.hand = []; p.lastSearchIndex = 0; });
    document.getElementById('center-play').innerHTML = '';
    for(let i=0; i<13; i++) {
        for(let p=0; p<4; p++) {
            players[p].hand.push(deck.pop());
        }
    }
    players.forEach(p => sortHand(p.hand));
    resetRoundState();
    renderAllHands();
    updateInfoUI();
    if(checkDragon()) return; 
    determineFirstPlayer();
    checkTurn();
}

function resetRoundState() {
    isRoundActive = false;
    isFirstTurnOfGame = true;
    lastPlay = null;
    passCount = 0;
    roundPassed = {};
    currentRoundMaxPlayer = 0;
    consecutivePassCount = 0;
    currentRoundPlays = [];
}

function createDeck() {
    let d = [];
    for(let s=0; s<4; s++) {
        for(let r=3; r<=15; r++) {
            let apiR = API_RANKS[r];
            let apiS = SUITS[s].substring(0,1); 
            let img = `https://deckofcardsapi.com/static/img/${apiR}${apiS}.png`;
            if(r===10) img = `https://deckofcardsapi.com/static/img/0${apiS}.png`;
            d.push({
                rank: r, suit: s, 
                val: r*10 + s, 
                img: img, id: `${r}-${s}`,
                suitName: SUIT_NAMES[s],
                rankName: apiR
            });
        }
    }
    return d;
}

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

function sortHand(hand) {
    hand.sort((a,b) => a.val - b.val);
}

function determineFirstPlayer() {
    for(let i=0; i<4; i++) {
        if(players[i].hand.some(c => c.rank === 3 && c.suit === 0)) {
            currentTurn = i;
            break;
        }
    }
    const name = players[currentTurn].isHuman ? 'ä½ ' : `AI ${currentTurn}`;
    showMsg(`ç”± ${name} æŒæœ‰ 3â™£ å…ˆæ‰‹`);
}

/* ================= æ ¸å¿ƒé‚è¼¯ ================= */
function checkDragon() {
    for(let i=0; i<4; i++) {
        const p = players[i];
        const ranks = new Set(p.hand.map(c => c.rank));
        if(ranks.size === 13) {
            showMsg(`ç©å®¶ ${i} ä¸€æ¢é¾ç²å‹ï¼`);
            handleRoundEnd(i, true); 
            return true;
        }
    }
    return false;
}

function checkTurn() {
    if(!isGameRunning) return;
    document.querySelectorAll('.player').forEach(el => el.classList.remove('active'));
    document.getElementById(`player-${currentTurn}`).classList.add('active');
    document.querySelectorAll('.smart-btn').forEach(btn => btn.classList.remove('active-hint'));
    updateBtnState();

    if(players[currentTurn].isHuman) {
        showMsg(isRoundActive ? "è¼ªåˆ°ä½ äº†" : "è‡ªç”±å‡ºç‰Œ");
        players[0].lastSearchIndex = 0;
        if(!isRoundActive && !isFirstTurnOfGame) {
            ['pair', 'straight', 'fullhouse', 'fourkind', 'straightflush'].forEach(type => {
                const candidates = findCandidates(type);
                if(candidates.length > 0) {
                    document.getElementById(`smart-${type}`).classList.add('active-hint');
                }
            });
        } else {
            checkSmartHints();
        }
    } else {
        setTimeout(aiThink, 1000);
    }
}

function nextTurn() {
    if(players[currentTurn].hand.length === 0) {
        handleRoundEnd(currentTurn, false);
        return; 
    }
    
    let nextPlayer = (currentTurn + 1) % 4;
    let iterations = 0;
    
    while (iterations < 4) {
        if (roundPassed[nextPlayer]) {
            nextPlayer = (nextPlayer + 1) % 4;
            iterations++;
            continue;
        }
        if (nextPlayer === currentTurn && isRoundActive) break;
        currentTurn = nextPlayer;
        checkTurn();
        return;
    }
    
    // ä¸‰äººéƒ½éï¼Œé‡ç½®
    if (Object.keys(roundPassed).length >= 3) {
        setTimeout(() => {
            isRoundActive = false;
            isFirstTurnOfGame = false;
            lastPlay = null;
            document.getElementById('center-play').innerHTML = '';
            const winnerName = players[currentRoundMaxPlayer].isHuman ? 'ä½ ' : `AI ${currentRoundMaxPlayer}`;
            showMsg(`${winnerName} å–å¾—è‡ªç”±å‡ºç‰Œæ¬Š`);
            currentTurn = currentRoundMaxPlayer;
            roundPassed = {};
            consecutivePassCount = 0;
            renderAllHands();
            updateBtnState();
            checkTurn();
        }, 1000);
    } else {
        currentTurn = (currentTurn + 1) % 4;
        checkTurn();
    }
}

/* ================= çµç®—ç³»çµ± ================= */
function handleRoundEnd(winnerIdx, isSpecialWin) {
    if (!isGameRunning) return;
    isGameRunning = false;
    
    const winnerName = players[winnerIdx].isHuman ? 'ä½ ' : `AI ${winnerIdx}`;
    showMsg(`è´å®¶: ${winnerName}`);
    
    if(!isSpecialWin && typeof confetti === 'function') {
        try {
            confetti({ particleCount: 300, spread: 120, origin: { y: 0.6 }, colors: ['#ffd700', '#ff0000', '#ffffff'] });
        } catch(e) { console.log("Confetti error:", e); }
    }

    let summaryData = [];
    let totalWin = 0;
    let winMultiplier = 1;
    let specialWinType = "";
    
    if(lastPlay && lastPlay.pIdx === winnerIdx) {
        if(lastPlay.type === 'fourkind') { winMultiplier = 2; specialWinType = "éµæ”¯çµæŸ x2"; }
        else if(lastPlay.type === 'straightflush') { winMultiplier = 2; specialWinType = "åŒèŠ±é †çµæŸ x2"; }
        else if(lastPlay.cards && lastPlay.cards.some(c => c.rank === 15)) { winMultiplier = 2; specialWinType = "å«2çµæŸ x2"; }
    }
    
    players.forEach(p => {
        let change = 0;
        let penaltyType = "";
        
        if(p.id !== winnerIdx) {
            let count = p.hand.length;
            let baseCost = count * gameStake;
            let multiplier = winMultiplier;
            
            const hasTwo = p.hand.some(c => c.rank === 15);
            const hasFourKind = checkHandHasFourKind(p.hand);
            const hasStraightFlush = checkHandHasStraightFlush(p.hand);
            
            if(hasTwo) { multiplier *= 2; penaltyType += "[å«2]"; }
            if(hasFourKind) { multiplier *= 2; penaltyType += "[éµæ”¯]"; }
            if(hasStraightFlush) { multiplier *= 2; penaltyType += "[åŒèŠ±é †]"; }
            if(count > 10 || isSpecialWin) multiplier *= 2;
            
            let cost = baseCost * multiplier;
            p.chips -= cost;
            totalWin += cost;
            change = -cost;
        } else {
            change = 0;
        }
        
        summaryData.push({
            player: p,
            change: change,
            isWinner: p.id === winnerIdx,
            penaltyType: penaltyType,
            remainingCards: [...p.hand]
        });
    });
    
    players[winnerIdx].chips += totalWin;
    summaryData[winnerIdx].change = totalWin;
    summaryData[winnerIdx].penaltyType = specialWinType;
    
    showRoundSummary(summaryData);
    updateInfoUI();
}

function checkHandHasFourKind(hand) {
    if(hand.length < 4) return false;
    const groups = {};
    hand.forEach(c => { groups[c.rank] = (groups[c.rank] || 0) + 1; });
    return Object.values(groups).some(count => count === 4);
}

function checkHandHasStraightFlush(hand) {
    if(hand.length < 5) return false;
    const suits = {};
    hand.forEach(c => {
        if(!suits[c.suit]) suits[c.suit] = [];
        suits[c.suit].push(c);
    });
    for(const suit in suits) {
        const cards = suits[suit].sort((a,b) => a.rank - b.rank);
        if(cards.length < 5) continue;
        for(let i=0; i<=cards.length-5; i++) {
            let continuous = true;
            for(let j=0; j<4; j++) {
                if(cards[i+j+1].rank - cards[i+j].rank !== 1) {
                    continuous = false; break;
                }
            }
            if(continuous) return true;
        }
    }
    return false;
}

function showRoundSummary(summaryData) {
    const modal = document.getElementById('round-summary');
    const content = document.getElementById('summary-content');
    content.innerHTML = '';
    
    summaryData.forEach((data, index) => {
        const div = document.createElement('div');
        div.className = `summary-player ${data.isWinner ? 'winner' : 'loser'}`;
        div.style.animation = `fadeInUp 0.5s ease-out ${index * 0.1}s both`;
        
        const name = data.player.isHuman ? 'ç©å®¶ (ä½ )' : `AI ${data.player.id}`;
        const changeClass = data.change > 0 ? 'positive' : (data.change < 0 ? 'negative' : '');
        const changeText = data.change > 0 ? `+$${data.change.toLocaleString()}` : (data.change < 0 ? `-$${Math.abs(data.change).toLocaleString()}` : '$0');
        
        let cardsHtml = '';
        if(data.remainingCards.length > 0) {
            cardsHtml = `<div style="font-size:0.85rem;color:#888;margin:8px 0;">å‰©é¤˜ ${data.remainingCards.length} å¼µç‰Œ:</div>`;
            cardsHtml += '<div class="summary-cards">';
            // åªé¡¯ç¤ºéƒ¨åˆ†ç‰Œé¿å…éé•·
            const displayCards = data.remainingCards.slice(0, 13);
            displayCards.forEach(card => {
                cardsHtml += `<div class="card" title="${card.rankName}${card.suitName}"><img src="${card.img}"></div>`;
            });
            if(data.remainingCards.length > 13) {
                cardsHtml += `<div style="color:#666; font-size:0.8rem; align-self:center;">+${data.remainingCards.length-13}</div>`;
            }
            cardsHtml += '</div>';
        } else {
            cardsHtml = '<div style="color:#00e676;font-weight:900;margin-top:15px; font-size:1.2rem;">ğŸ† ç‡å…ˆå‡ºå®Œï¼</div>';
        }
        
        div.innerHTML = `
            <div class="summary-name">${name} ${data.isWinner ? 'ğŸ‘‘' : ''}</div>
            <div class="summary-chips ${changeClass}">${changeText}</div>
            ${data.penaltyType ? `<div class="special-penalty">${data.penaltyType}</div>` : ''}
            ${cardsHtml}
        `;
        content.appendChild(div);
    });
    
    // æ·»åŠ å‹•ç•«æ¨£å¼
    if(!document.getElementById('anim-style')) {
        const style = document.createElement('style');
        style.id = 'anim-style';
        style.textContent = `
            @keyframes fadeInUp {
                from { opacity: 0; transform: translateY(30px); }
                to { opacity: 1; transform: translateY(0); }
            }
        `;
        document.head.appendChild(style);
    }
    
    modal.style.display = 'flex';
}

function closeRoundSummary() {
    document.getElementById('round-summary').style.display = 'none';
    if(players.some(p => p.chips <= 0)) {
        gameOver();
    } else {
        document.getElementById('center-play').innerHTML = '';
        if (gameMode === 'exchange') {
            startExchangeRound();
        } else {
            startNewRound();
        }
    }
}

function gameOver() {
    const overlay = document.getElementById('modal-overlay');
    const screen = document.getElementById('game-over-screen');
    const title = document.getElementById('go-title');
    const msg = document.getElementById('go-msg');
    
    document.getElementById('start-screen').style.display = 'none';
    overlay.style.display = 'flex';
    screen.style.display = 'block';

    const human = players[0];
    if(human.chips <= 0) {
        title.style.color = '#ff5252';
        title.textContent = "YOU LOSE";
        msg.textContent = "ç±Œç¢¼æ­¸é›¶ï¼Œä½ ç ´ç”¢äº†ï¼";
    } else {
        title.style.color = '#ffd700';
        title.textContent = "YOU WIN";
        msg.textContent = `æœ€çµ‚ç±Œç¢¼: $${human.chips.toLocaleString()}`;
    }
}

/* ================= æ™ºæ…§é¸ç‰Œ ================= */
function findCandidates(targetType) {
    const hand = players[0].hand;
    const groups = {};
    hand.forEach(c => { if(!groups[c.rank]) groups[c.rank]=[]; groups[c.rank].push(c); });
    let candidates = [];

    if(targetType === 'pair') {
        candidates = Object.values(groups).filter(g => g.length >= 2).map(g => g.slice(0,2));
    } else if (targetType === 'fullhouse') {
        const threes = Object.values(groups).filter(g => g.length === 3);
        const pairs = Object.values(groups).filter(g => g.length >= 2);
        threes.forEach(t => {
           pairs.forEach(p => {
               if(p[0].rank !== t[0].rank) candidates.push([...t, p[0], p[1]]);
           });
        });
    } else if (targetType === 'fourkind') {
        const fours = Object.values(groups).filter(g => g.length === 4);
        fours.forEach(f => {
            hand.forEach(kicker => {
                if(kicker.rank !== f[0].rank) candidates.push([...f, kicker]);
            });
        });
    } else if (targetType === 'straight') {
        const unique = [];
        const seen = new Set();
        hand.forEach(c => { if(!seen.has(c.rank)) { seen.add(c.rank); unique.push(c); }});
        unique.sort((a,b) => a.rank - b.rank);
        for(let i=0; i <= unique.length-5; i++) {
            const sub = unique.slice(i, i+5);
            let isSeq = true;
            for(let k=0; k<4; k++) if(sub[k+1].rank - sub[k].rank !== 1) isSeq = false;
            if(isSeq) candidates.push(sub);
        }
    } else if (targetType === 'straightflush') {
        const suits = {};
        hand.forEach(c => {
            if(!suits[c.suit]) suits[c.suit] = [];
            suits[c.suit].push(c);
        });
        for(const suit in suits) {
            const sameSuitCards = suits[suit].sort((a,b) => a.rank - b.rank);
            if(sameSuitCards.length < 5) continue;
            for(let i=0; i <= sameSuitCards.length-5; i++) {
                const sub = sameSuitCards.slice(i, i+5);
                let isSeq = true;
                for(let k=0; k<4; k++) if(sub[k+1].rank - sub[k].rank !== 1) isSeq = false;
                const isA2345 = (sub[0].rank === 14 && sub[1].rank === 2 && sub[2].rank === 3 && sub[3].rank === 4 && sub[4].rank === 5);
                if(isSeq && !isA2345) candidates.push(sub);
            }
        }
    }
    return candidates;
}

function checkSmartHints() {
    ['pair', 'straight', 'fullhouse', 'fourkind', 'straightflush'].forEach(type => {
        const candidates = findCandidates(type);
        if(candidates.length === 0) return; 
        let hasPlayable = false;
        if(!isRoundActive) hasPlayable = true;
        else {
            const playable = candidates.filter(combo => validatePlayMatch(combo));
            if(playable.length > 0) hasPlayable = true;
        }
        if(hasPlayable) document.getElementById(`smart-${type}`).classList.add('active-hint');
    });
}

function autoSelect(targetType) {
    if(currentTurn !== 0) return;
    clearSelection();
    const candidates = findCandidates(targetType);
    if(candidates.length === 0) { showMsg("ç„¡æ­¤ç‰Œå‹"); return; }
    let validCandidates = isRoundActive 
        ? candidates.filter(combo => validatePlayMatch(combo))
        : candidates;
    if(isFirstTurnOfGame) validCandidates = validCandidates.filter(c => c.some(card => card.val === 30));
    if(validCandidates.length === 0) { showMsg("ç„¡æ³•å£“ç‰Œ"); return; }
    let idx = players[0].lastSearchIndex % validCandidates.length;
    const targetCards = validCandidates[idx];
    players[0].lastSearchIndex++;
    targetCards.forEach(c => {
        const el = Array.from(document.querySelectorAll('#hand-0 .card')).find(e => parseInt(e.dataset.val) === c.val);
        if(el) el.classList.add('selected');
    });
    updateBtnState();
}

function clearSelection() {
    document.querySelectorAll('#hand-0 .card').forEach(el => el.classList.remove('selected'));
    updateBtnState();
}

/* ================= å‡ºç‰Œèˆ‡é©—è­‰ï¼ˆæ ¸å¿ƒè¦å‰‡ä¿®æ­£ï¼‰ ================= */
function humanPlay() {
    const handDiv = document.getElementById('hand-0');
    const selectedEls = handDiv.querySelectorAll('.selected');
    const cards = Array.from(selectedEls).map(el => {
        const idx = parseInt(el.dataset.idx);
        return players[0].hand[idx];
    }).filter(c => c);

    if(cards.length === 0) {
        showMsg("è«‹é¸æ“‡ç‰Œ");
        return;
    }

    const result = validatePlay(cards);
    if(result.valid) {
        animatePlayCards(0, cards, result.handInfo);
    } else {
        showMsg(result.msg);
        gsap.to('#hand-0', {x:15, yoyo:true, repeat:5, duration:0.05});
    }
}

function humanPass() {
    if(!isRoundActive) return;
    executePass(0);
}

/* é£›è¡Œå‡ºç‰Œå‹•ç•«ï¼ˆä¿®æ­£ç‚ºç·Šå¯†å †ç–Šç›®æ¨™ï¼‰ */
function animatePlayCards(pIdx, cards, handInfo) {
    const p = players[pIdx];
    const handDiv = document.getElementById(`hand-${pIdx}`);
    const center = document.getElementById('center-play');
    const centerRect = center.getBoundingClientRect();
    const centerX = centerRect.left + centerRect.width / 2;
    const centerY = centerRect.top + centerRect.height / 2;
    
    // è¨˜éŒ„æ•¸æ“š
    const cardValues = cards.map(c => c.val);
    playedCardsHistory.push(...cards);
    currentRoundPlays.push({ player: pIdx, cards: cards, type: handInfo.type });
    
    // æ¸…ç©ºèˆŠç‰Œï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰ï¼Œå› ç‚ºæ¯æ¬¡åªé¡¯ç¤ºç•¶å‰å‡ºçš„ç‰Œ
    center.innerHTML = '';
    
    // æ‰¾åˆ°DOMå…ƒç´ ä¸¦å‰µå»ºé£›è¡Œå‹•ç•«
    const cardEls = [];
    cards.forEach((card, i) => {
        const el = handDiv.querySelector(`.card[data-val="${card.val}"]`);
        if(el) {
            const rect = el.getBoundingClientRect();
            const clone = el.cloneNode(true);
            // å¦‚æœæ˜¯AIå‡ºç‰Œï¼ˆéäººé¡ï¼‰ï¼Œç›´æ¥é¡¯ç¤ºç‰Œé¢æ­£é¢
             if(pIdx !== 0) {
            clone.innerHTML = `<img src="${card.img}">`;
            }
            clone.className = 'flying-card';
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.left = rect.left + 'px';
            clone.style.top = rect.top + 'px';
            document.body.appendChild(clone);
            cardEls.push(clone);
            
            // è¨ˆç®—ç›®æ¨™ä½ç½®ï¼šç·Šå¯†å †ç–Šï¼ˆèˆ‡CSS margin-left: -68pxå°æ‡‰ï¼‰
            // ç¸½å¯¬åº¦ = 75 + (n-1)*7ï¼Œç½®ä¸­
            const cardWidth = 75;
            const overlap = 68; // èˆ‡CSSä¸€è‡´
            const totalWidth = cardWidth + (cards.length - 1) * (cardWidth - overlap);
            const startX = centerX - totalWidth / 2;
            const targetX = startX + i * (cardWidth - overlap);
            const targetY = centerY - 105/2; // 105æ˜¯cardé«˜åº¦
            
            // é£›è¡Œå‹•ç•«
            gsap.to(clone, {
                left: targetX,
                top: targetY,
                width: cardWidth, // çµ±ä¸€è®Šç‚ºä¸­å¤®å€åŸŸç‰Œå¤§å°
                height: 105,
                rotation: 0,
                duration: 0.5,
                ease: "power2.out",
                delay: i * 0.05,
                onComplete: () => {
                    clone.remove();
                    // æ·»åŠ åˆ°ä¸­å¤®å€åŸŸï¼Œä½¿ç”¨ç·Šå¯†å †ç–Šæ¨£å¼
                    const div = document.createElement('div');
                    div.className = 'card';
                    div.style.zIndex = i; // ä¾åºç–ŠåŠ ï¼Œæœ€å¾Œä¸€å¼µåœ¨æœ€ä¸Š
                    div.innerHTML = `<img src="${card.img}">`;
                    center.appendChild(div);
                }
            });
        }
    });
    
    // å»¶é²æ›´æ–°æ‰‹ç‰Œèˆ‡ç‹€æ…‹
    setTimeout(() => {
        p.hand = p.hand.filter(c => !cardValues.includes(c.val));
        updateLastPlayInfo(pIdx, cards, handInfo);
    }, 600);
}

function updateLastPlayInfo(pIdx, cards, handInfo) {
    lastPlay = { 
        pIdx: pIdx, 
        type: handInfo.type, 
        score: handInfo.score, 
        count: cards.length,
        cards: cards
    };
    
    isRoundActive = true;
    passCount = 0; 
    if(isFirstTurnOfGame) isFirstTurnOfGame = false;
    consecutivePassCount = 0;
    currentRoundMaxPlayer = pIdx;

    renderAllHands();
    updateInfoUI(); 
    
    // é¡¯ç¤ºç‰Œå‹æ¨™ç±¤
    if(handInfo.type !== 'single') {
        showHandTypeTag(handInfo.type);
        showPop(pIdx, getHandTypeDisplayName(handInfo.type), '#ffd700');
    }
    
    nextTurn();
}

function getHandTypeDisplayName(type) {
    const names = {
       'pair': 'å°å­',
       'straight': 'é †å­',
       'fullhouse': 'è‘«è˜†',
       'fourkind': 'éµæ”¯',
       'straightflush': 'åŒèŠ±é †'
   };
   return names[type] || type;
}

function showHandTypeTag(type) {
   const center = document.getElementById('center-play');
   // ç§»é™¤èˆŠæ¨™ç±¤é¿å…é‡ç–Š
   const oldTag = center.querySelector('.hand-type-tag');
   if(oldTag) oldTag.remove();
   
   const tag = document.createElement('div');
   tag.className = 'hand-type-tag';
   tag.textContent = getHandTypeDisplayName(type);
   center.appendChild(tag);
   setTimeout(() => tag.remove(), 2000);
}

function executePass(pIdx) {
   showPop(pIdx, "PASS", '#9e9e9e');
   passCount++;
   roundPassed[pIdx] = true;
   consecutivePassCount++;
   
   const passedCount = Object.keys(roundPassed).length;
   if (passedCount >= 3) {
       setTimeout(() => {
           isRoundActive = false;
           isFirstTurnOfGame = false;
           lastPlay = null;
           document.getElementById('center-play').innerHTML = '';
           const winnerName = players[currentRoundMaxPlayer].isHuman ? 'ä½ ' : `AI ${currentRoundMaxPlayer}`;
           showMsg(`${winnerName} å–å¾—è‡ªç”±å‡ºç‰Œæ¬Š`);
           currentTurn = currentRoundMaxPlayer;
           roundPassed = {};
           consecutivePassCount = 0;
           renderAllHands();
           updateBtnState();
           checkTurn();
       }, 800);
   } else {
       nextTurn();
   }
}

/* æ ¸å¿ƒè¦å‰‡é©—è­‰ï¼ˆå·²ä¿®æ­£å¤§è€äºŒè¦å‰‡ï¼‰ */
function canBeat(lastType, newType, lastCount, newCount) {
   // éµæ”¯ç‰¹æ®Šè¦å‰‡ï¼šå¯ä»¥å£“ä»»æ„å¼µæ•¸ï¼ˆå–®å¼µã€å°å­ã€ä¸‰å¼µã€äº”å¼µä¸­çš„é †å­/è‘«è˜†ï¼‰
   if (newType === 'fourkind') {
       if (newCount === 5 && lastCount !== 5) return true; // äº”å¼µéµæ”¯å£“éäº”å¼µ
       if (lastCount === 5) {
           // äº”å¼µä¹‹é–“æ¯”è¼ƒï¼šéµæ”¯å¯å£“é †å­ã€è‘«è˜†ã€éµæ”¯ï¼Œä¸å¯å£“åŒèŠ±é †
           const lastRank = HAND_RANK[lastType] || 0;
           return lastRank <= 3; // é †å­(1)ã€è‘«è˜†(2)ã€éµæ”¯(3)
       }
       return false; // åŒå¼µæ•¸éµæ”¯æ¯”å¤§å°åœ¨å¾Œé¢è™•ç†
   }
   
   // åŒèŠ±é †ç‰¹æ®Šè¦å‰‡ï¼šå¯å£“ä»»ä½•äº”å¼µçµ„åˆï¼ˆåŒ…æ‹¬éµæ”¯ï¼‰
   if (newType === 'straightflush') {
       if (lastCount !== 5) return false; // åŒèŠ±é †æ˜¯äº”å¼µç‰Œï¼Œåªèƒ½å£“äº”å¼µ
       const lastRank = HAND_RANK[lastType] || 0;
       // å¯å£“é †å­ã€è‘«è˜†ã€éµæ”¯ã€åŒèŠ±é †
       return true;
   }
   
   // äº”å¼µç‰Œå‹ä¹‹é–“çš„å£“åˆ¶ï¼ˆééµæ”¯ã€éåŒèŠ±é †çš„æƒ…æ³ï¼‰
   if (newCount === 5 && lastCount === 5) {
       // é †å­åªèƒ½å£“é †å­
       if (newType === 'straight') return lastType === 'straight';
       
       // è‘«è˜†åªèƒ½å£“è‘«è˜†
       if (newType === 'fullhouse') return lastType === 'fullhouse';
   }
   
   return false;
}

function validatePlayMatch(cards) {
   const info = getHandType(cards);
   if(!info) return false;
   if(!lastPlay) return true;
   
   const newCount = cards.length;
   const lastCount = lastPlay.count;
   const newType = info.type;
   const lastType = lastPlay.type;
   
   // åŒå¼µæ•¸åŒç‰Œå‹æ¯”å¤§å°
   if (newCount === lastCount && newType === lastType) {
       return info.score > lastPlay.score;
   }
   
   // ä¸åŒæƒ…æ³ä½¿ç”¨å£“åˆ¶è¦å‰‡
   return canBeat(lastType, newType, lastCount, newCount);
}

function validatePlay(cards) {
   if(cards.length === 0) return { valid: false, msg: "è«‹é¸ç‰Œ" };
   const handInfo = getHandType(cards);
   if(!handInfo) return { valid: false, msg: "ç‰Œå‹éŒ¯èª¤" };

   if(isFirstTurnOfGame) {
       if(!cards.some(c => c.rank === 3 && c.suit === 0)) return { valid: false, msg: "é¦–è¼ªéœ€åŒ…å« 3â™£" };
   }

   if(!isRoundActive && !isFirstTurnOfGame) {
       return { valid: true, handInfo };
   }

   if(isRoundActive && lastPlay) {
       const newCount = cards.length;
       const lastCount = lastPlay.count;
       const newType = handInfo.type;
       const lastType = lastPlay.type;
       
       // åŒå¼µæ•¸åŒç‰Œå‹æ¯”å¤§å°
       if (newCount === lastCount && newType === lastType) {
           if (handInfo.score > lastPlay.score) return { valid: true, handInfo };
           return { valid: false, msg: "ç‰Œä¸å¤ å¤§" };
       }
       
       // æª¢æŸ¥ç‰¹æ®Šå£“åˆ¶è¦å‰‡
       if (canBeat(lastType, newType, lastCount, newCount)) {
           return { valid: true, handInfo };
       }
       
       // éŒ¯èª¤æç¤º
       if (newCount !== lastCount) {
           if (newType === 'fourkind') return { valid: true, handInfo }; // éµæ”¯ç‰¹æ®Šæƒ…æ³å·²åœ¨canBeatè™•ç†
           return { valid: false, msg: "å¼µæ•¸ä¸ç¬¦ï¼ˆéµæ”¯é™¤å¤–ï¼‰" };
       }
       
       if (lastType === 'straight' && newType === 'fullhouse') return { valid: false, msg: "è‘«è˜†ä¸èƒ½å£“é †å­" };
       if (lastType === 'fullhouse' && newType === 'straight') return { valid: false, msg: "é †å­ä¸èƒ½å£“è‘«è˜†" };
       if (newType === 'straight' || newType === 'fullhouse') return { valid: false, msg: "åªèƒ½å£“åŒé¡ç‰Œå‹" };
       
       return { valid: false, msg: "ç‰Œå‹ç„¡æ³•å£“åˆ¶" };
   }
   return { valid: true, handInfo };
}

function getHandType(cards) {
   if(!cards || cards.length === 0) return null;
   cards = [...cards].sort((a,b) => a.rank - b.rank); 
   const len = cards.length;
   
   if(len === 1) return { type: 'single', score: cards[0].val };
   
   if(len === 2) {
       if(cards[0].rank === cards[1].rank) return { type: 'pair', score: cards[1].val }; 
       return null;
   }
   
   if(len === 5) {
       const counts = {};
       cards.forEach(c => counts[c.rank] = (counts[c.rank]||0)+1);
       const vals = Object.values(counts);
       const isFlush = cards.every(c => c.suit === cards[0].suit);
       
       let isStraight = false;
       let straightScore = 0;
       const r = cards.map(c=>c.rank);
       
       // é †å­åˆ¤æ–·ï¼ˆå«A-2-3-4-5ç‰¹æ®Šé †å­ï¼‰
       if(r[0] === 14 && r[1] === 2 && r[2] === 3 && r[3] === 4 && r[4] === 5) {
           isStraight = true;
           straightScore = 100 + 14 * 10; // Aç•¶1ç”¨ï¼Œæœ€å°é †å­
       } else if(r[4] - r[0] === 4 && new Set(r).size === 5) {
           isStraight = true;
           straightScore = 200 + r[4] * 10 + r[4]; // æ­£å¸¸é †å­
       }
       
       // åŒèŠ±é †ï¼ˆæœ€å¤§ï¼‰
       if(isStraight && isFlush) {
           // åˆ†æ•¸çµæ§‹ï¼š40000 + é †å­åŸºç¤åˆ† + èŠ±è‰²ï¼ˆç¢ºä¿åŒèŠ±é †ä¹‹é–“å¯æ¯”ï¼‰
           // èŠ±è‰²è¶Šå¤§è¶Šå¼·ï¼Œé»‘æ¡ƒ(3)>ç´…å¿ƒ(2)>æ–¹å¡Š(1)>æ¢…èŠ±(0)
           return { type: 'straightflush', score: 40000 + straightScore + cards[0].suit };
       }
       
       // éµæ”¯ï¼ˆæ¬¡å¤§ï¼Œå¯å£“è‘«è˜†ã€é †å­ï¼‰
       if(vals.includes(4)) {
           const fourRank = parseInt(Object.keys(counts).find(k => counts[k] === 4));
           return { type: 'fourkind', score: 45000 + fourRank * 10 };
       }
       
       // è‘«è˜†
       if(vals.includes(3) && vals.includes(2)) {
           const threeRank = parseInt(Object.keys(counts).find(k => counts[k] === 3));
           return { type: 'fullhouse', score: 20000 + threeRank * 10 };
       }
       
       // é †å­
       if(isStraight) {
           return { type: 'straight', score: 10000 + straightScore };
       }
   }
   return null;
}

/* ================= UI Utils ================= */
function renderAllHands() {
   players.forEach(p => {
       const div = document.getElementById(`hand-${p.id}`);
       if(!div) return;
       div.innerHTML = '';
       p.hand.forEach((card, idx) => {
           const el = document.createElement('div');
           el.className = 'card';
           if(roundPassed[p.id] && !p.isHuman) {
               el.style.filter = 'grayscale(100%) brightness(0.6)';
               el.style.opacity = '0.4';
           }
           const imgSrc = p.isHuman ? card.img : BACK_IMG;
           el.innerHTML = `<img src="${imgSrc}">`;
           el.dataset.idx = idx;
           el.dataset.val = card.val;
           el.style.zIndex = idx; 

           if(p.isHuman) {
               el.onclick = () => { 
                   el.classList.toggle('selected'); 
                   updateBtnState(); 
               };
           }
           div.appendChild(el);
       });
   });
}

function updateInfoUI() {
   document.getElementById('my-chips').textContent = `$${players[0].chips.toLocaleString()}`;
   document.getElementById('my-cnt').textContent = players[0].hand.length;
   for(let i=1; i<=3; i++) {
       if(document.getElementById(`chips-${i}`)) {
           const chips = players[i].chips;
           document.getElementById(`chips-${i}`).textContent = `$${chips >= 10000 ? (chips/1000).toFixed(1) + 'k' : chips}`;
           document.getElementById(`cnt-${i}`).textContent = players[i].hand.length;
       }
   }
}

function updateBtnState() {
   const selected = document.querySelectorAll('#hand-0 .selected');
   const playBtn = document.getElementById('btn-play');
   const passBtn = document.getElementById('btn-pass');
   if(currentTurn !== 0) {
       playBtn.disabled = true; passBtn.disabled = true; return;
   }
   playBtn.disabled = (selected.length === 0);
   passBtn.disabled = (isFirstTurnOfGame || !isRoundActive); 
}

function showMsg(txt, duration = 2000) {
   const box = document.getElementById('info-box');
   box.textContent = txt; 
   box.style.display = 'block';
   setTimeout(() => box.style.display = 'none', duration);
}

function showPop(pIdx, text, color='#ffd700') {
   const p = document.getElementById(`player-${pIdx}`);
   if(!p) return;
   const div = document.createElement('div');
   div.className = 'msg-pop';
   div.textContent = text;
   div.style.color = color;
   if(pIdx===0) div.style.bottom = '140px';
   else if(pIdx===2) div.style.top = '120px';
   else div.style.top = '50%';
   
   p.appendChild(div);
   setTimeout(() => div.remove(), 1500);
}

/* ================= åŠ å¼·ç‰ˆ AIï¼ˆç¬¦åˆæ–°è¦å‰‡ï¼‰ ================= */
function aiThink() {
   if(!isGameRunning) return;
   const ai = players[currentTurn];
   let hand = [...ai.hand];
   hand.sort((a,b) => a.val - b.val);
   
   let possiblePlays = [];
   
   // å–®å¼µ
   hand.forEach(card => {
       possiblePlays.push({cards:[card], info: {type:'single', score:card.val}, size:1});
   });
   
   // å°å­
   for(let i=0; i<hand.length-1; i++) {
       if(hand[i].rank === hand[i+1].rank) {
           possiblePlays.push({
               cards: [hand[i], hand[i+1]], 
               info: {type:'pair', score:hand[i+1].val}, 
               size:2
           });
       }
   }
   
   // äº”å¼µç‰Œå‹
   if(hand.length >= 5) {
       const uniqueRanks = [...new Set(hand.map(c => c.rank))].sort((a,b)=>a-b);
       
       // é †å­èˆ‡åŒèŠ±é †
       for(let i=0; i<=uniqueRanks.length-5; i++) {
           const ranks = uniqueRanks.slice(i, i+5);
           if(ranks[4]-ranks[0] === 4 || (ranks[0]===14 && ranks[1]===2 && ranks[4]===5)) {
               const combo = ranks.map(r => hand.find(c => c.rank === r)).filter(c=>c);
               if(combo.length === 5) {
                   const info = getHandType(combo);
                   if(info) possiblePlays.push({cards:combo, info, size:5});
               }
           }
       }
       
       // è‘«è˜†
       const groups = {};
       hand.forEach(c => { groups[c.rank] = (groups[c.rank]||0)+1; });
       const threes = Object.entries(groups).filter(([k,v]) => v>=3).map(([k,v]) => parseInt(k));
       const pairs = Object.entries(groups).filter(([k,v]) => v>=2).map(([k,v]) => parseInt(k));
       threes.forEach(t => {
           pairs.forEach(p => {
               if(t !== p) {
                   const cards = [
                       ...hand.filter(c => c.rank === t).slice(0,3),
                       ...hand.filter(c => c.rank === p).slice(0,2)
                   ];
                   const info = getHandType(cards);
                   if(info) possiblePlays.push({cards, info, size:5});
               }
           });
       });
       
       // éµæ”¯
       const fours = Object.entries(groups).filter(([k,v]) => v===4).map(([k,v]) => parseInt(k));
       fours.forEach(f => {
           const kickers = hand.filter(c => c.rank !== f);
           kickers.forEach(kicker => {
               const cards = [...hand.filter(c => c.rank === f), kicker];
               const info = getHandType(cards);
               if(info) possiblePlays.push({cards, info, size:5});
           });
       });
   }
   
   // éæ¿¾å¯å£“ç‰Œçš„é¸é …
   let validPlays = possiblePlays;
   if(isRoundActive && lastPlay) {
       validPlays = possiblePlays.filter(play => {
           return validatePlayMatch(play.cards);
       });
   }
   
   if(isFirstTurnOfGame) {
       validPlays = validPlays.filter(play => play.cards.some(c => c.rank === 3 && c.suit === 0));
   }
   
   if(validPlays.length > 0) {
       let bestPlay;
       if(!isRoundActive) {
           validPlays.sort((a,b) => a.info.score - b.info.score);
           const singles = validPlays.filter(p => p.size === 1);
           bestPlay = singles.length > 0 ? singles[0] : validPlays[0];
       } else {
           validPlays.sort((a,b) => a.info.score - b.info.score);
           bestPlay = validPlays[0];
       }
       
       const toPlay = bestPlay.cards.map(c => ai.hand.find(card => card.val === c.val)).filter(c => c);
       if(toPlay.length === bestPlay.cards.length) {
           animatePlayCards(currentTurn, toPlay, bestPlay.info);
       } else {
           executePass(currentTurn);
       }
   } else {
       executePass(currentTurn);
   }
}
</script>
<script>
 if ('serviceWorker' in navigator) {
   window.addEventListener('load', () => {
     navigator.serviceWorker.register('sw.js')
       .then(reg => console.log('SW registered: ', reg))
       .catch(err => console.log('SW registration failed: ', err));
   });
 }
</script>
</body>
</html>












