<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="manifest" href="manifest.json">   <!-- 改這裡 -->
<link rel="apple-touch-icon" href="icons/icon-192.png">   <!-- 改這裡 -->
<title>大老二 – 職業賭場版 (Mobile)</title>

<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700;900&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.7.0/dist/confetti.browser.min.js"></script>

<style>
    :root{
        /* 變數：區分玩家與電腦卡牌大小 */
        --human-card-w: 90px;
        --human-card-h: 126px;
        --human-gap: -45px; /* 手牌重疊度 */
        
        --ai-card-w: 45px;
        --ai-card-h: 63px;
        --ai-gap: -25px;
        
        --btm-bar-height: 40px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
    
    body {
        font-family: 'Rubik', sans-serif;
        background: #000;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        color: #fff;
    }

    /* === 強制橫屏提示 === */
    #portrait-lock {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: #000; z-index: 9999;
        display: none; flex-direction: column;
        justify-content: center; align-items: center;
        text-align: center; color: #ffca28;
    }
    #portrait-lock span { font-size: 3rem; margin-bottom: 20px; display: block; }
    #portrait-lock p { font-size: 1.2rem; color: #fff; }

    /* 只在直屏時顯示 */
    @media screen and (orientation: portrait) {
        #portrait-lock { display: flex; }
        #game-wrapper { display: none !important; }
    }

    /* === 遊戲主容器 === */
    #game-wrapper {
        width: 100%; height: 100%;
        position: relative;
        background: radial-gradient(circle at center, #2e7d32 0%, #1b5e20 100%); /* 綠色賭桌風格 */
        overflow: hidden;
    }
    
    /* 桌面裝飾 */
    #game-wrapper::before {
        content: "";
        position: absolute; top: 10%; left: 10%; right: 10%; bottom: 25%;
        border: 2px solid rgba(255,255,255,0.1);
        border-radius: 40px; pointer-events: none;
    }

    /* === 底部黑底白字狀態列 (參考圖片) === */
    #bottom-bar {
        position: absolute; bottom: 0; left: 0; width: 100%;
        height: var(--btm-bar-height);
        background: #000;
        z-index: 500;
        display: flex; align-items: center; justify-content: space-between;
        padding: 0 20px;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
        font-size: 0.9rem;
    }
    .bar-section { display: flex; align-items: center; gap: 15px; }
    .bar-label { color: #888; font-size: 0.8rem; margin-right: 5px; }
    .bar-val { color: #fff; font-weight: bold; font-family: monospace; font-size: 1.1rem; }
    .bar-money { color: #ffd700; } /* 金幣色 */

    /* === 玩家區域通用 === */
    .player { position: absolute; z-index: 100; pointer-events: none; }
    
    /* === 手牌容器 === */
    .hand { display: flex; justify-content: center; align-items: center; }

    /* 卡牌樣式 */
    .card {
        border-radius: 4px; background: #fff;
        box-shadow: -1px 1px 3px rgba(0,0,0,0.3);
        position: relative; flex-shrink: 0;
        transition: transform 0.2s, margin 0.2s;
    }
    .card img { width: 100%; height: 100%; object-fit: contain; border-radius: 4px; display: block; }

    /* --- 自己 (Human) --- */
    #player-0 {
        bottom: var(--btm-bar-height); /* 緊貼底部黑條 */
        left: 0; width: 100%;
        height: auto;
        padding-bottom: 5px;
        z-index: 200;
        pointer-events: auto; /* 允許點擊 */
    }
    #player-0 .hand {
        height: var(--human-card-h);
        margin: 0 auto;
        width: 100%;
        max-width: 900px; /* 限制最大寬度以免在大螢幕太散 */
    }
    #player-0 .card {
        width: var(--human-card-w); height: var(--human-card-h);
        margin-left: var(--human-gap);
        cursor: pointer;
        box-shadow: -2px 0 5px rgba(0,0,0,0.4);
    }
    #player-0 .card:first-child { margin-left: 0; }
    
    /* 選中與互動 */
    #player-0 .card.selected {
        transform: translateY(-20px);
        border: 2px solid #ffeb3b;
        box-shadow: 0 0 10px #ffeb3b;
    }
    
    /* 輪到自己時的高亮 */
    #player-0.active::after {
        content: ""; position: absolute; bottom: 0; left: 0; width: 100%; height: 5px;
        background: #ffeb3b; box-shadow: 0 0 15px #ffeb3b;
        animation: glowLine 1.5s infinite;
    }
    @keyframes glowLine { 0%{opacity:0.5;} 50%{opacity:1;} 100%{opacity:0.5;} }

    /* --- AI 對手 (簡化顯示) --- */
    /* 上方 AI (Player 2) */
    #player-2 { top: 10px; left: 50%; transform: translateX(-50%); }
    #player-2 .hand .card { 
        width: var(--ai-card-w); height: var(--ai-card-h); margin-left: var(--ai-gap); 
    }

    /* 左側 AI (Player 3) */
    #player-3 { top: 35%; left: 15px; transform: translateY(-50%); }
    #player-3 .hand { flex-direction: column; }
    #player-3 .hand .card { 
        width: var(--ai-card-h); height: var(--ai-card-w); /* 轉向 */
        margin-left: 0; margin-bottom: var(--ai-gap); 
        transform: rotate(90deg);
    }

    /* 右側 AI (Player 1) */
    #player-1 { top: 35%; right: 15px; transform: translateY(-50%); }
    #player-1 .hand { flex-direction: column; }
    #player-1 .hand .card { 
        width: var(--ai-card-h); height: var(--ai-card-w);
        margin-left: 0; margin-bottom: var(--ai-gap); 
        transform: rotate(-90deg);
    }

    /* AI 資訊小牌子 (不再使用浮動大框，改為小標籤) */
    .ai-info-tag {
        background: rgba(0,0,0,0.6); padding: 2px 8px; border-radius: 4px;
        color: #fff; font-size: 0.75rem; text-align: center; margin: 5px;
        border: 1px solid #aaa; backdrop-filter: blur(2px);
    }
    #player-2 .ai-info-tag { margin-bottom: 2px; }
    .player.active .ai-info-tag { background: #ffb300; color: #000; font-weight: bold; border-color: #fff; }

    /* === 中央出牌區 === */
    #center-play {
        position: absolute; left: 50%; top: 40%;
        transform: translate(-50%, -50%);
        width: 300px; height: 120px;
        display: flex; justify-content: center; align-items: center;
        z-index: 50; pointer-events: none;
    }
    /* 出的牌大小適中 */
    #center-play .card {
        width: 70px; height: 98px; margin-left: -35px;
    }
    
    /* === 操作按鈕區 (調整至手牌上方) === */
    #controls-area {
        position: absolute;
        bottom: calc(var(--human-card-h) + var(--btm-bar-height) + 20px);
        left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center; gap: 10px;
        z-index: 300; pointer-events: none; /* 讓點擊穿透到背景，按鈕本身開啟pointer-events */
        width: 100%;
    }

    /* 主要按鈕 (PASS/出牌) */
    .btn-group-main { display: flex; gap: 20px; pointer-events: auto; }
    
    button.action-btn {
        padding: 8px 30px; border-radius: 50px; border: none;
        font-weight: 900; font-size: 1rem; color: #fff;
        box-shadow: 0 4px 0 rgba(0,0,0,0.3);
        transition: transform 0.1s; cursor: pointer;
    }
    button.action-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 rgba(0,0,0,0.3); }
    
    button.btn-play { background: linear-gradient(to bottom, #4caf50, #2e7d32); }
    button.btn-pass { background: linear-gradient(to bottom, #f44336, #c62828); }
    button:disabled { filter: grayscale(1); opacity: 0.6; cursor: not-allowed; }

    /* 智慧選牌按鈕 (縮小並半透明) */
    .smart-group {
        display: flex; gap: 5px;
        background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 20px;
        pointer-events: auto; opacity: 0; transition: 0.3s;
    }
    #player-0.active ~ #controls-area .smart-group { opacity: 1; }

    button.smart-btn {
        background: transparent; border: 1px solid #aaa; color: #ddd;
        padding: 4px 8px; font-size: 0.75rem; border-radius: 4px; cursor: pointer;
    }
    button.smart-btn:hover { background: rgba(255,255,255,0.2); }
    button.smart-btn.active-hint {
        background: #ffeb3b; color: #000; border-color: #ffeb3b;
        font-weight: bold; box-shadow: 0 0 8px #ffeb3b;
    }

    /* === 彈窗 Modal === */
    #modal-overlay {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.85); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
        backdrop-filter: blur(5px);
    }
    .modal-box {
        background: linear-gradient(135deg, #263238, #102027);
        padding: 30px; border-radius: 16px; text-align: center;
        border: 2px solid #ffd700; width: 400px; max-width: 90%;
    }
    .stake-btn {
        margin: 5px; padding: 10px 20px; background: #37474f; border: 1px solid #546e7a;
        color: #fff; border-radius: 8px; cursor: pointer;
    }
    .stake-btn.selected { background: #ffd700; color: #000; border-color: #fff; }

    /* 浮動訊息 */
    .msg-pop {
        position: absolute; font-size: 2rem; font-weight: 900;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        pointer-events: none; z-index: 600;
    }
    
    /* 響應式調整 */
    @media (max-width: 768px) {
        :root {
            --human-card-w: 60px; --human-card-h: 84px; --human-gap: -30px;
        }
        #center-play .card { width: 50px; height: 70px; margin-left: -25px; }
        .ai-info-tag { font-size: 0.6rem; padding: 1px 5px; }
    }
</style>
</head>
<body>

<div id="portrait-lock">
    <span>↻</span>
    <p>為了最佳體驗<br>請將手機橫向旋轉</p>
</div>

<div id="game-wrapper">

    <div id="bottom-bar">
        <div class="bar-section">
            <span class="bar-label">籌碼</span>
            <span id="my-chips" class="bar-val bar-money">$10,000</span>
        </div>
        <div style="flex:1;"></div> <div class="bar-section">
            <span class="bar-label">剩餘</span>
            <span id="my-cnt" class="bar-val">0</span>
            <span class="bar-label" style="margin-left:2px;">張</span>
        </div>
    </div>
    <div id="modal-overlay">
        <div class="modal-box" id="start-screen">
            <h2 style="color:#ffd700; margin-bottom:15px;">CASINO BIG TWO</h2>
            <p style="color:#ccc; font-size:0.9rem; margin-bottom:20px;">選擇底注</p>
            <div>
                <button class="stake-btn" onclick="startGame(50)">$50</button>
                <button class="stake-btn selected" onclick="startGame(100)">$100</button>
                <button class="stake-btn" onclick="startGame(200)">$200</button>
            </div>
        </div>
        
        <div class="modal-box" id="game-over-screen" style="display:none;">
            <h2 id="go-title" style="margin-bottom:15px;">GAME OVER</h2>
            <p id="go-msg" style="margin-bottom:20px;"></p>
            <button class="stake-btn selected" onclick="location.reload()">再玩一次</button>
        </div>
    </div>

    <div id="center-play"></div>
    <div id="info-box" style="position:absolute; top:20%; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.7); padding:5px 15px; border-radius:20px; display:none;">提示</div>

    <div id="player-0" class="player active">
        <div class="hand" id="hand-0"></div>
    </div>
    
    <div id="controls-area">
        <div class="btn-group-main">
            <button id="btn-pass" class="action-btn btn-pass" onclick="humanPass()">PASS</button>
            <button id="btn-play" class="action-btn btn-play" onclick="humanPlay()">出牌</button>
        </div>
        <div class="smart-group">
            <button id="smart-pair" class="smart-btn" onclick="autoSelect('pair')">對子</button>
            <button id="smart-straight" class="smart-btn" onclick="autoSelect('straight')">順子</button>
            <button id="smart-fullhouse" class="smart-btn" onclick="autoSelect('fullhouse')">葫蘆</button>
            <button id="smart-fourkind" class="smart-btn" onclick="autoSelect('fourkind')">鐵支</button>
            <button class="smart-btn" onclick="clearSelection()">重選</button>
        </div>
    </div>

    <div id="player-1" class="player ai">
        <div class="ai-info-tag">AI 1: <span id="chips-1">$10000</span> (<span id="cnt-1">0</span>)</div>
        <div class="hand" id="hand-1"></div>
    </div>
    
    <div id="player-2" class="player ai">
        <div class="ai-info-tag">AI 2: <span id="chips-2">$10000</span> (<span id="cnt-2">0</span>)</div>
        <div class="hand" id="hand-2"></div>
    </div>
    
    <div id="player-3" class="player ai">
        <div class="ai-info-tag">AI 3: <span id="chips-3">$10000</span> (<span id="cnt-3">0</span>)</div>
        <div class="hand" id="hand-3"></div>
    </div>
</div>

<script>
/* ================= 全局變數 ================= */
const SUITS = ['C','D','H','S']; 
const API_RANKS = {3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'0',11:'J',12:'Q',13:'K',14:'A',15:'2'};
// 為了視覺清爽，對手背面使用純色或簡單圖案，這裡沿用API背面
const BACK_IMG = "https://deckofcardsapi.com/static/img/back.png";

let players = [];
let currentTurn = 0;   
let lastPlay = null;   
let passCount = 0;     
let isRoundActive = false; 
let isFirstTurnOfGame = true;
let gameStake = 100;
let isGameRunning = false;
let lastSuccessfulPlayer = 0;   // 新增：最後成功出牌的玩家（用來重開新輪）

/* ================= 初始化 ================= */
function initPlayers() {
    players = Array(4).fill(0).map((_, i) => ({
        id: i,
        isHuman: i === 0,
        hand: [],
        chips: 10000,
        lastSearchIndex: 0
    }));
    updateInfoUI();
}

function startGame(stake) {
    gameStake = stake;
    document.getElementById('modal-overlay').style.display = 'none';
    initPlayers();
    startNewRound();
}

function startNewRound() {
    if(players.some(p => p.chips <= 0)) {
        gameOver();
        return;
    }

    isGameRunning = true;
    let deck = createDeck();
    shuffle(deck);

    players.forEach(p => { p.hand = []; p.lastSearchIndex = 0; });
    document.getElementById('center-play').innerHTML = '';

    for(let i=0; i<13; i++) {
        for(let p=0; p<4; p++) {
            players[p].hand.push(deck.pop());
        }
    }
    players.forEach(p => sortHand(p.hand));

    isRoundActive = false;
    isFirstTurnOfGame = true;
    lastPlay = null;
    passCount = 0;

    renderAllHands();
    updateInfoUI();

    if(checkDragon()) return; 

    determineFirstPlayer();
    checkTurn();
}

function createDeck() {
    let d = [];
    for(let s=0; s<4; s++) {
        for(let r=3; r<=15; r++) {
            let apiR = API_RANKS[r];
            let apiS = SUITS[s].substring(0,1); 
            let img = `https://deckofcardsapi.com/static/img/${apiR}${apiS}.png`;
            if(r===10) img = `https://deckofcardsapi.com/static/img/0${apiS}.png`;
            d.push({
                rank: r, suit: s, 
                val: r*10 + s, 
                img: img, id: `${r}-${s}`
            });
        }
    }
    return d;
}

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

function sortHand(hand) {
    hand.sort((a,b) => a.val - b.val);
}

function determineFirstPlayer() {
    for(let i=0; i<4; i++) {
        if(players[i].hand.some(c => c.rank === 3 && c.suit === 0)) {
            currentTurn = i;
            break;
        }
    }
    showMsg(`由玩家 ${players[currentTurn].isHuman ? '你' : currentTurn} (3♣) 先手`);
}

/* ================= 核心邏輯 ================= */
function checkDragon() {
    for(let i=0; i<4; i++) {
        const p = players[i];
        const ranks = new Set(p.hand.map(c => c.rank));
        if(ranks.size === 13) {
            showMsg(`玩家 ${i} 一條龍獲勝！`);
            handleRoundEnd(i, true); 
            return true;
        }
    }
    return false;
}

function checkTurn() {
    if(!isGameRunning) return;
    document.querySelectorAll('.player').forEach(el => el.classList.remove('active'));
    document.getElementById(`player-${currentTurn}`).classList.add('active');

    document.querySelectorAll('.smart-btn').forEach(btn => btn.classList.remove('active-hint'));

    updateBtnState();

    if(players[currentTurn].isHuman) {
        showMsg(isRoundActive ? "輪到你了" : "自由出牌");
        players[0].lastSearchIndex = 0;
        checkSmartHints();
    } else {
        setTimeout(aiThink, 1000);
    }
}

function nextTurn() {
    if(players[currentTurn].hand.length === 0) {
        handleRoundEnd(currentTurn, false);
        return; 
    }
    currentTurn = (currentTurn + 1) % 4; 
    checkTurn();
}

/* ================= 結算 ================= */
function handleRoundEnd(winnerIdx, isSpecialWin) {
    isGameRunning = false;
    showMsg(`贏家: ${players[winnerIdx].isHuman?'你':`AI ${winnerIdx}`}`);
    if(!isSpecialWin) confetti({ particleCount: 200, spread: 120, origin: { y: 0.6 } });

    let totalWin = 0;
    players.forEach(p => {
        if(p.id !== winnerIdx) {
            let count = p.hand.length;
            let cost = count * gameStake;
            if(count > 10 || isSpecialWin) cost *= 2;    
            
            p.chips -= cost;
            totalWin += cost;
            showPop(p.id, `-$${cost}`, '#ff5252');
        }
    });

    players[winnerIdx].chips += totalWin;
    showPop(winnerIdx, `+$${totalWin}`, '#4caf50');
    
    updateInfoUI();

    if(players.some(p => p.chips <= 0)) {
        setTimeout(gameOver, 2500);
    } else {
        setTimeout(startNewRound, 3000);
    }
}

function gameOver() {
    const overlay = document.getElementById('modal-overlay');
    const screen = document.getElementById('game-over-screen');
    const title = document.getElementById('go-title');
    const msg = document.getElementById('go-msg');
    
    document.getElementById('start-screen').style.display = 'none';
    overlay.style.display = 'flex';
    screen.style.display = 'block';

    const human = players[0];
    if(human.chips <= 0) {
        title.style.color = '#ef5350';
        title.textContent = "YOU LOSE";
        msg.textContent = "籌碼歸零，你破產了！";
    } else {
        title.style.color = '#ffd700';
        title.textContent = "YOU WIN";
        msg.textContent = `最終籌碼: $${human.chips}`;
    }
}

/* ================= 智慧選牌 ================= */
function findCandidates(targetType) {
    const hand = players[0].hand;
    const groups = {};
    hand.forEach(c => { if(!groups[c.rank]) groups[c.rank]=[]; groups[c.rank].push(c); });
    let candidates = [];

    if(targetType === 'pair') {
        candidates = Object.values(groups).filter(g => g.length >= 2).map(g => g.slice(0,2));
    } else if (targetType === 'fullhouse') {
        const threes = Object.values(groups).filter(g => g.length === 3);
        const pairs = Object.values(groups).filter(g => g.length >= 2);
        threes.forEach(t => {
           pairs.forEach(p => {
               if(p[0].rank !== t[0].rank) candidates.push([...t, p[0], p[1]]);
           });
        });
    } else if (targetType === 'fourkind') {
        const fours = Object.values(groups).filter(g => g.length === 4);
        fours.forEach(f => {
            hand.forEach(kicker => {
                if(kicker.rank !== f[0].rank) candidates.push([...f, kicker]);
            });
        });
    } else if (targetType === 'straight') {
        const unique = [];
        const seen = new Set();
        hand.forEach(c => { if(!seen.has(c.rank)) { seen.add(c.rank); unique.push(c); }});
        for(let i=0; i <= unique.length-5; i++) {
            const sub = unique.slice(i, i+5);
            let isSeq = true;
            for(let k=0; k<4; k++) if(sub[k+1].rank - sub[k].rank !== 1) isSeq = false;
            if(isSeq) candidates.push(sub);
        }
    }
    return candidates;
}

function checkSmartHints() {
    ['pair', 'straight', 'fullhouse', 'fourkind'].forEach(type => {
        const candidates = findCandidates(type);
        if(candidates.length === 0) return; 

        let hasPlayable = false;
        if(!isRoundActive) hasPlayable = true;
        else {
            const playable = candidates.filter(combo => validatePlayMatch(combo));
            if(playable.length > 0) hasPlayable = true;
        }

        if(hasPlayable) document.getElementById(`smart-${type}`).classList.add('active-hint');
    });
}

function autoSelect(targetType) {
    if(currentTurn !== 0) return;
    clearSelection();
    
    const candidates = findCandidates(targetType);
    if(candidates.length === 0) { showMsg("無此牌型"); return; }

    let validCandidates = isRoundActive 
        ? candidates.filter(combo => validatePlayMatch(combo))
        : candidates;

    if(isFirstTurnOfGame) validCandidates = validCandidates.filter(c => c.some(card => card.val === 30));

    if(validCandidates.length === 0) { showMsg("無法壓牌"); return; }

    let idx = players[0].lastSearchIndex % validCandidates.length;
    const targetCards = validCandidates[idx];
    players[0].lastSearchIndex++;

    targetCards.forEach(c => {
        const el = Array.from(document.querySelectorAll('#hand-0 .card')).find(e => parseInt(e.dataset.val) === c.val);
        if(el) el.classList.add('selected');
    });
    updateBtnState();
}

function clearSelection() {
    document.querySelectorAll('#hand-0 .card').forEach(el => el.classList.remove('selected'));
    updateBtnState();
}

/* ================= 出牌與驗證 ================= */
function humanPlay() {
    const handDiv = document.getElementById('hand-0');
    const selectedEls = handDiv.querySelectorAll('.selected');
    const cards = Array.from(selectedEls).map(el => players[0].hand[parseInt(el.dataset.idx)]);

    const result = validatePlay(cards);
    if(result.valid) {
        executePlay(0, cards, result.handInfo);
    } else {
        showMsg(result.msg);
        gsap.to('#hand-0', {x:10, yoyo:true, repeat:3, duration:0.05});
    }
}

function humanPass() {
    if(!isRoundActive) return;
    executePass(0);
}

function executePlay(pIdx, cards, handInfo) {
    const p = players[pIdx];
    p.hand = p.hand.filter(c => !cards.some(played => played.val === c.val));
    
    const center = document.getElementById('center-play');
    center.innerHTML = '';
    cards.forEach((c, i) => {
        const div = document.createElement('div');
        div.className = 'card';
        div.style.zIndex = i;
        div.innerHTML = `<img src="${c.img}">`;
        center.appendChild(div);
    });
    
    gsap.from('#center-play .card', {scale: 1.5, opacity:0, stagger:0.05, ease: "back.out(1.7)"});

    if(handInfo.type !== 'single') showPop(pIdx, handInfo.type.toUpperCase());

// 新增/修改這幾行
    lastPlay = { count: cards.length, score: info.score, type: info.type };
    isRoundActive = true;
    passCount = 0;                      // 重設 PASS 計數
    lastSuccessfulPlayer = pIdx;        // 記錄最後出牌者

    // 更新 UI...
    updateBtnState();

    renderAllHands();
    updateInfoUI(); 
    nextTurn();
    
    // 檢查是否結束遊戲
    if (players[pIdx].hand.length === 0) {
        // 贏家邏輯...
    }
    nextTurn(); // 假設你有這個函數輪到下家，或直接下面邏輯
}

function executePass(pIdx) {
    showPop(pIdx, 'PASS', '#ff5252');

    passCount++;  // PASS 次數 +1

    if (passCount === 3) {  // 其他 3 人全 PASS → 新輪由最後出牌者開始
        passCount = 0;
        isRoundActive = false;
        currentTurn = lastSuccessfulPlayer;
        showMsg('所有人 PASS，新的一輪由玩家 ' + (lastSuccessfulPlayer + 1) + ' 開始');
    } else {
        currentTurn = (currentTurn + 1) % 4;  // 正常輪到下家
    }

    updateBtnState();

    // 如果輪到 AI，延遲思考
    if (currentTurn !== 0) {
        setTimeout(aiThink, 800);
    }
}

function validatePlayMatch(cards) {
    const info = getHandType(cards);
    if(!info) return false;
    if(cards.length !== lastPlay.count) return false; 
    if(cards.length === 5) return info.score > lastPlay.score;
    if(info.type !== lastPlay.type) return false;
    return info.score > lastPlay.score;
}

function validatePlay(cards) {
    if(cards.length === 0) return { valid: false, msg: "請選牌" };
    const handInfo = getHandType(cards);
    if(!handInfo) return { valid: false, msg: "牌型錯誤" };

    if(isFirstTurnOfGame) {
        if(!cards.some(c => c.rank === 3 && c.suit === 0)) return { valid: false, msg: "需包含 3♣" };
    }

    if(isRoundActive && lastPlay) {
        if(cards.length !== lastPlay.count) return { valid: false, msg: "張數不符" };
        if(cards.length === 5) {
            if(handInfo.score > lastPlay.score) return { valid: true, handInfo };
            return { valid: false, msg: "牌不夠大" };
        } else {
            if(handInfo.type !== lastPlay.type) return { valid: false, msg: "牌型不符" };
            if(handInfo.score > lastPlay.score) return { valid: true, handInfo };
            return { valid: false, msg: "牌太小了" };
        }
    }
    return { valid: true, handInfo };
}

function getHandType(cards) {
    cards.sort((a,b) => a.rank - b.rank); 
    const len = cards.length;
    
    if(len === 1) return { type: 'single', score: cards[0].val };
    
    if(len === 2) {
        if(cards[0].rank === cards[1].rank) return { type: 'pair', score: cards[1].val }; 
        return null;
    }
    
    if(len === 5) {
        const counts = {};
        cards.forEach(c => counts[c.rank] = (counts[c.rank]||0)+1);
        const vals = Object.values(counts);
        const isFlush = cards.every(c => c.suit === cards[0].suit);
        
        let isStraight = false;
        let straightScore = 0;
        const r = cards.map(c=>c.rank);
        
        // 簡易順子判斷
        if(r[4]-r[0] === 4 && new Set(r).size===5) { isStraight = true; straightScore=200+cards[4].val; }
        // 3-4-5-A-2 or 3-4-5-6-2 etc (略化處理)
        if(!isStraight && r[0]===3 && r[1]===4 && r[2]===5) { isStraight=true; straightScore=100; }

        if(isStraight && isFlush) return { type: 'straightflush', score: 40000 + straightScore };
        if(vals.includes(4)) return { type: 'fourkind', score: 30000 + parseInt(Object.keys(counts).find(k=>counts[k]===4))*10 };
        if(vals.includes(3) && vals.includes(2)) return { type: 'fullhouse', score: 20000 + parseInt(Object.keys(counts).find(k=>counts[k]===3))*10 };
        if(isStraight) return { type: 'straight', score: 10000 + straightScore };
    }
    return null;
}

/* ================= UI Utils ================= */
function renderAllHands() {
    players.forEach(p => {
        const div = document.getElementById(`hand-${p.id}`);
        div.innerHTML = '';
        p.hand.forEach((card, idx) => {
            const el = document.createElement('div');
            el.className = 'card';
            // 只有自己顯示牌面，其他顯示背面
            const imgSrc = p.isHuman ? card.img : BACK_IMG;
            el.innerHTML = `<img src="${imgSrc}">`;
            el.dataset.idx = idx;
            el.dataset.val = card.val;
            el.style.zIndex = idx; 

            if(p.isHuman) {
                el.onclick = () => { el.classList.toggle('selected'); updateBtnState(); };
            }
            div.appendChild(el);
        });
    });
}

function updateInfoUI() {
    // 更新底部欄 Human (Player 0)
    document.getElementById('my-chips').textContent = `$${players[0].chips}`;
    document.getElementById('my-cnt').textContent = players[0].hand.length;

    // 更新 AI 標籤
    for(let i=1; i<=3; i++) {
        document.getElementById(`chips-${i}`).textContent = `$${players[i].chips}`;
        document.getElementById(`cnt-${i}`).textContent = players[i].hand.length;
    }
}

function updateBtnState() {
    const selected = document.querySelectorAll('#hand-0 .selected');
    const playBtn = document.getElementById('btn-play');
    const passBtn = document.getElementById('btn-pass');

    if(currentTurn !== 0) {
        playBtn.disabled = true; passBtn.disabled = true; return;
    }
    playBtn.disabled = (selected.length === 0);
    passBtn.disabled = (isFirstTurnOfGame || !isRoundActive); 
}

function showMsg(txt) {
    const box = document.getElementById('info-box');
    box.textContent = txt; box.style.display = 'block';
    setTimeout(() => box.style.display = 'none', 2000);
}

function showPop(pIdx, text, color='#ffeb3b') {
    const p = document.getElementById(`player-${pIdx}`);
    const div = document.createElement('div');
    div.className = 'msg-pop';
    div.textContent = text;
    div.style.color = color;
    
    // 位置微調
    if(pIdx===0) div.style.top = '-80px';
    else div.style.top = '0px';

    p.appendChild(div);
    gsap.fromTo(div, {y:20, opacity:0}, {y:-20, opacity:1, duration:0.4});
    gsap.to(div, {opacity:0, duration:0.5, delay: 0.8, onComplete:()=>div.remove()});
}

/* ================= 加強版 AI（保留五張 + 聰明管牌） ================= */
function getCombinations(arr, k) {
    const result = [];
    function helper(start, current) {
        if (current.length === k) {
            result.push([...current]);
            return;
        }
        for (let i = start; i < arr.length; i++) {
            current.push(arr[i]);
            helper(i + 1, current);
            current.pop();
        }
    }
    helper(0, []);
    return result;
}

function aiThink() {
    const ai = players[currentTurn];
    let hand = [...ai.hand];
    hand.sort((a, b) => a.val - b.val);

    let possiblePlays = [];

    // 單張
    hand.forEach(card => {
        const info = getHandType([card]);
        if (info) possiblePlays.push({ cards: [card], info, size: 1 });
    });

    // 對子
    for (let i = 0; i < hand.length - 1; i++) {
        if (hand[i].rank === hand[i + 1].rank) {
            const cards = [hand[i], hand[i + 1]];
            const info = getHandType(cards);
            if (info) possiblePlays.push({ cards, info, size: 2 });
            i++;
        }
    }

    // 五張（窮舉所有合法）
    if (hand.length >= 5) {
        const combos = getCombinations(hand, 5);
        combos.forEach(combo => {
            const sorted = [...combo].sort((a, b) => a.val - b.val);
            const info = getHandType(sorted);
            if (info) possiblePlays.push({ cards: combo, info, size: 5 });
        });
    }

    // 過濾能出的牌型
    let validPlays = possiblePlays;
    if (isRoundActive && lastPlay) {
        validPlays = possiblePlays.filter(play =>
            play.size === lastPlay.count &&
            play.info.type === lastPlay.type &&
            play.info.score > lastPlay.score
        );
    }

    // 首輪強制含 3♣
    if (isFirstTurnOfGame && validPlays.length > 0) {
        validPlays = validPlays.filter(play =>
            play.cards.some(c => c.rank === 3 && c.suit === 0)  // 假設 suit 0 = 梅花
        );
    }

    if (validPlays.length === 0) {
        executePass(currentTurn);
        return;
    }

    let best;
    if (!isRoundActive) {
        // 自由出牌：優先出最小的「非五張」牌型（保留五張炸彈）
        const nonFive = validPlays.filter(p => p.size !== 5);
        if (nonFive.length > 0) {
            nonFive.sort((a, b) => a.info.score - b.info.score);
            best = nonFive[0];
        } else {
            // 只能出五張時，出最小的五張（清牌）
            validPlays.sort((a, b) => a.info.score - b.info.score);
            best = validPlays[0];
        }
    } else {
        // 管牌時：如果有五張能管，優先出「最大的五張」（炸彈壓制）
        const five = validPlays.filter(p => p.size === 5);
        if (five.length > 0) {
            five.sort((a, b) => b.info.score - a.info.score);  // 最大先
            best = five[0];
        } else {
            validPlays.sort((a, b) => a.info.score - b.info.score);
            best = validPlays[0];
        }
    }

    // 用原物件出牌
    const toPlay = best.cards.map(c =>
        ai.hand.find(card => card.val === c.val && card.suit === c.suit && card.rank === c.rank)
    );
    executePlay(currentTurn, toPlay, best.info);
}
</script>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('sw.js')   // 去掉前導 /
        .then(reg => console.log('SW registered: ', reg))
        .catch(err => console.log('SW registration failed: ', err));
    });
  }
</script>
</body>

</html>






