<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<title>大老二 – 職業賭場版 (Mobile)</title>

<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700;900&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.7.0/dist/confetti.browser.min.js"></script>

<style>
    :root{
        /* 變數：區分玩家與電腦卡牌大小 */
        --human-card-w: 90px;
        --human-card-h: 126px;
        --human-gap: -45px; /* 手牌重疊度 */
        
        --ai-card-w: 45px;
        --ai-card-h: 63px;
        --ai-gap: -25px;
        
        --btm-bar-height: 40px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
    
    body {
        font-family: 'Rubik', sans-serif;
        background: #000;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        color: #fff;
    }

    /* === 強制橫屏提示 === */
    #portrait-lock {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: #000; z-index: 9999;
        display: none; flex-direction: column;
        justify-content: center; align-items: center;
        text-align: center; color: #ffca28;
    }
    #portrait-lock span { font-size: 3rem; margin-bottom: 20px; display: block; }
    #portrait-lock p { font-size: 1.2rem; color: #fff; }

    /* 只在直屏時顯示 */
    @media screen and (orientation: portrait) {
        #portrait-lock { display: flex; }
        #game-wrapper { display: none !important; }
    }

    /* === 遊戲主容器 === */
    #game-wrapper {
        width: 100%; height: 100%;
        position: relative;
        background: radial-gradient(circle at center, #2e7d32 0%, #1b5e20 100%); /* 綠色賭桌風格 */
        overflow: hidden;
    }
    
    /* 桌面裝飾 */
    #game-wrapper::before {
        content: "";
        position: absolute; top: 10%; left: 10%; right: 10%; bottom: 25%;
        border: 2px solid rgba(255,255,255,0.1);
        border-radius: 40px; pointer-events: none;
    }

    /* === 底部黑底白字狀態列 (參考圖片) === */
    #bottom-bar {
        position: absolute; bottom: 0; left: 0; width: 100%;
        height: var(--btm-bar-height);
        background: #000;
        z-index: 500;
        display: flex; align-items: center; justify-content: space-between;
        padding: 0 20px;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
        font-size: 0.9rem;
    }
    .bar-section { display: flex; align-items: center; gap: 15px; }
    .bar-label { color: #888; font-size: 0.8rem; margin-right: 5px; }
    .bar-val { color: #fff; font-weight: bold; font-family: monospace; font-size: 1.1rem; }
    .bar-money { color: #ffd700; } /* 金幣色 */

    /* === 玩家區域通用 === */
    .player { position: absolute; z-index: 100; pointer-events: none; }
    
    /* === 手牌容器 === */
    .hand { display: flex; justify-content: center; align-items: center; }

    /* 卡牌樣式 */
    .card {
        border-radius: 4px; background: #fff;
        box-shadow: -1px 1px 3px rgba(0,0,0,0.3);
        position: relative; flex-shrink: 0;
        transition: transform 0.2s, margin 0.2s;
    }
    .card img { width: 100%; height: 100%; object-fit: contain; border-radius: 4px; display: block; }

    /* --- 自己 (Human) --- */
    #player-0 {
        bottom: var(--btm-bar-height); /* 緊貼底部黑條 */
        left: 0; width: 100%;
        height: auto;
        padding-bottom: 5px;
        z-index: 200;
        pointer-events: auto; /* 允許點擊 */
    }
    #player-0 .hand {
        height: var(--human-card-h);
        margin: 0 auto;
        width: 100%;
        max-width: 900px; /* 限制最大寬度以免在大螢幕太散 */
    }
    #player-0 .card {
        width: var(--human-card-w); height: var(--human-card-h);
        margin-left: var(--human-gap);
        cursor: pointer;
        box-shadow: -2px 0 5px rgba(0,0,0,0.4);
    }
    #player-0 .card:first-child { margin-left: 0; }
    
    /* 選中與互動 */
    #player-0 .card.selected {
        transform: translateY(-20px);
        border: 2px solid #ffeb3b;
        box-shadow: 0 0 10px #ffeb3b;
    }
    
    /* 輪到自己時的高亮 */
    #player-0.active::after {
        content: ""; position: absolute; bottom: 0; left: 0; width: 100%; height: 5px;
        background: #ffeb3b; box-shadow: 0 0 15px #ffeb3b;
        animation: glowLine 1.5s infinite;
    }
    @keyframes glowLine { 0%{opacity:0.5;} 50%{opacity:1;} 100%{opacity:0.5;} }

    /* --- AI 對手 (簡化顯示) --- */
    /* 上方 AI (Player 2) */
    #player-2 { top: 10px; left: 50%; transform: translateX(-50%); }
    #player-2 .hand .card { 
        width: var(--ai-card-w); height: var(--ai-card-h); margin-left: var(--ai-gap); 
    }

    /* 左側 AI (Player 3) */
    #player-3 { top: 35%; left: 15px; transform: translateY(-50%); }
    #player-3 .hand { flex-direction: column; }
    #player-3 .hand .card { 
        width: var(--ai-card-h); height: var(--ai-card-w); /* 轉向 */
        margin-left: 0; margin-bottom: var(--ai-gap); 
        transform: rotate(90deg);
    }

    /* 右側 AI (Player 1) */
    #player-1 { top: 35%; right: 15px; transform: translateY(-50%); }
    #player-1 .hand { flex-direction: column; }
    #player-1 .hand .card { 
        width: var(--ai-card-h); height: var(--ai-card-w);
        margin-left: 0; margin-bottom: var(--ai-gap); 
        transform: rotate(-90deg);
    }

    /* AI 資訊小牌子 (不再使用浮動大框，改為小標籤) */
    .ai-info-tag {
        background: rgba(0,0,0,0.6); padding: 2px 8px; border-radius: 4px;
        color: #fff; font-size: 0.75rem; text-align: center; margin: 5px;
        border: 1px solid #aaa; backdrop-filter: blur(2px);
    }
    #player-2 .ai-info-tag { margin-bottom: 2px; }
    .player.active .ai-info-tag { background: #ffb300; color: #000; font-weight: bold; border-color: #fff; }

    /* === 中央出牌區 === */
    #center-play {
        position: absolute; left: 50%; top: 40%;
        transform: translate(-50%, -50%);
        width: 300px; height: 120px;
        display: flex; justify-content: center; align-items: center;
        z-index: 50; pointer-events: none;
    }
    /* 出的牌大小適中 */
    #center-play .card {
        width: 70px; height: 98px; margin-left: -35px;
    }
    
    /* === 操作按鈕區 (調整至手牌上方) === */
    #controls-area {
        position: absolute;
        bottom: calc(var(--human-card-h) + var(--btm-bar-height) + 20px);
        left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center; gap: 10px;
        z-index: 300; pointer-events: none; /* 讓點擊穿透到背景，按鈕本身開啟pointer-events */
        width: 100%;
    }

    /* 主要按鈕 (PASS/出牌) */
    .btn-group-main { display: flex; gap: 20px; pointer-events: auto; }
    
    button.action-btn {
        padding: 8px 30px; border-radius: 50px; border: none;
        font-weight: 900; font-size: 1rem; color: #fff;
        box-shadow: 0 4px 0 rgba(0,0,0,0.3);
        transition: transform 0.1s; cursor: pointer;
    }
    button.action-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 rgba(0,0,0,0.3); }
    
    button.btn-play { background: linear-gradient(to bottom, #4caf50, #2e7d32); }
    button.btn-pass { background: linear-gradient(to bottom, #f44336, #c62828); }
    button:disabled { filter: grayscale(1); opacity: 0.6; cursor: not-allowed; }

    /* 智慧選牌按鈕 (縮小並半透明) */
    .smart-group {
        display: flex; gap: 5px;
        background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 20px;
        pointer-events: auto; opacity: 0; transition: 0.3s;
    }
    #player-0.active ~ #controls-area .smart-group { opacity: 1; }

    button.smart-btn {
        background: transparent; border: 1px solid #aaa; color: #ddd;
        padding: 4px 8px; font-size: 0.75rem; border-radius: 4px; cursor: pointer;
    }
    button.smart-btn:hover { background: rgba(255,255,255,0.2); }
    button.smart-btn.active-hint {
        background: #ffeb3b; color: #000; border-color: #ffeb3b;
        font-weight: bold; box-shadow: 0 0 8px #ffeb3b;
    }

    /* === 彈窗 Modal === */
    #modal-overlay {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.85); z-index: 2000;
        display: flex; justify-content: center; align-items: center;
        backdrop-filter: blur(5px);
    }
    .modal-box {
        background: linear-gradient(135deg, #263238, #102027);
        padding: 30px; border-radius: 16px; text-align: center;
        border: 2px solid #ffd700; width: 400px; max-width: 90%;
    }
    .stake-btn {
        margin: 5px; padding: 10px 20px; background: #37474f; border: 1px solid #546e7a;
        color: #fff; border-radius: 8px; cursor: pointer;
    }
    .stake-btn.selected { background: #ffd700; color: #000; border-color: #fff; }
    
    /* MODIFIED: 新增交換局按鈕樣式 */
    .mode-btn {
        padding: 10px 20px; margin: 10px 5px; background: #37474f; 
        border: 1px solid #546e7a; color: #fff; border-radius: 8px; 
        cursor: pointer; font-weight: 500;
    }
    .mode-btn.selected { background: #ffd700; color: #000; border-color: #fff; }
    
    /* MODIFIED: 新增交換局UI樣式 */
    #exchange-ui {
        position: absolute; bottom: calc(var(--human-card-h) + var(--btm-bar-height) + 80px);
        left: 50%; transform: translateX(-50%);
        display: none; flex-direction: column; align-items: center; gap: 10px;
        z-index: 400; pointer-events: auto;
        width: 100%;
    }
    #exchange-btn {
        padding: 10px 30px; background: #4caf50; border: none; 
        border-radius: 50px; color: white; font-weight: bold;
        cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.3);
    }
    #exchange-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 rgba(0,0,0,0.3); }
    
    /* 浮動訊息 */
    .msg-pop {
        position: absolute; font-size: 2rem; font-weight: 900;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        pointer-events: none; z-index: 600;
    }
    
    /* 響應式調整 */
    @media (max-width: 768px) {
        :root {
            --human-card-w: 60px; --human-card-h: 84px; --human-gap: -30px;
        }
        #center-play .card { width: 50px; height: 70px; margin-left: -25px; }
        .ai-info-tag { font-size: 0.6rem; padding: 1px 5px; }
    }
</style>
</head>
<body>

<div id="portrait-lock">
    <span>↻</span>
    <p>為了最佳體驗<br>請將手機橫向旋轉</p>
</div>

<div id="game-wrapper">

    <div id="bottom-bar">
        <div class="bar-section">
            <span class="bar-label">籌碼</span>
            <span id="my-chips" class="bar-val bar-money">$10,000</span>
        </div>
        <div style="flex:1;"></div> <div class="bar-section">
            <span class="bar-label">剩餘</span>
            <span id="my-cnt" class="bar-val">0</span>
            <span class="bar-label" style="margin-left:2px;">張</span>
        </div>
    </div>
    <div id="modal-overlay">
        <div class="modal-box" id="start-screen">
            <h2 style="color:#ffd700; margin-bottom:15px;">CASINO BIG TWO</h2>
            <p style="color:#ccc; font-size:0.9rem; margin-bottom:20px;">選擇底注</p>
            <!-- MODIFIED: 新增一般局和交換局按鈕 -->
            <div style="margin-bottom:15px;">
                <button id="mode-normal" class="mode-btn selected" onclick="selectGameMode('normal')">一般局</button>
                <button id="mode-exchange" class="mode-btn" onclick="selectGameMode('exchange')">交換局</button>
            </div>
            <div>
                <button class="stake-btn" onclick="startGame(50)">$50</button>
                <button class="stake-btn selected" onclick="startGame(100)">$100</button>
                <button class="stake-btn" onclick="startGame(200)">$200</button>
            </div>
        </div>
        
        <div class="modal-box" id="game-over-screen" style="display:none;">
            <h2 id="go-title" style="margin-bottom:15px;">GAME OVER</h2>
            <p id="go-msg" style="margin-bottom:20px;"></p>
            <button class="stake-btn selected" onclick="location.reload()">再玩一次</button>
        </div>
    </div>

    <div id="center-play"></div>
    <div id="info-box" style="position:absolute; top:20%; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.7); padding:5px 15px; border-radius:20px; display:none;">提示</div>

    <div id="player-0" class="player active">
        <div class="hand" id="hand-0"></div>
    </div>
    
    <!-- MODIFIED: 新增交換局按鈕區域 -->
    <div id="exchange-ui">
        <button id="exchange-btn" onclick="performExchange()">交換</button>
    </div>
    
    <div id="controls-area">
        <div class="btn-group-main">
            <button id="btn-pass" class="action-btn btn-pass" onclick="humanPass()">PASS</button>
            <button id="btn-play" class="action-btn btn-play" onclick="humanPlay()">出牌</button>
        </div>
<div class="smart-group">
    <button id="smart-pair" class="smart-btn" onclick="autoSelect('pair')">對子</button>
    <button id="smart-straight" class="smart-btn" onclick="autoSelect('straight')">順子</button>
    <button id="smart-fullhouse" class="smart-btn" onclick="autoSelect('fullhouse')">葫蘆</button>
    <button id="smart-fourkind" class="smart-btn" onclick="autoSelect('fourkind')">鐵支</button>
    <!-- 新增同花順按鈕 -->
    <button id="smart-straightflush" class="smart-btn" onclick="autoSelect('straightflush')">同花順</button>
    <button class="smart-btn" onclick="clearSelection()">重選</button>
</div>
    </div>

    <div id="player-1" class="player ai">
        <div class="ai-info-tag">AI 1: <span id="chips-1">$10000</span> (<span id="cnt-1">0</span>)</div>
        <div class="hand" id="hand-1"></div>
    </div>
    
    <div id="player-2" class="player ai">
        <div class="ai-info-tag">AI 2: <span id="chips-2">$10000</span> (<span id="cnt-2">0</span>)</div>
        <div class="hand" id="hand-2"></div>
    </div>
    
    <div id="player-3" class="player ai">
        <div class="ai-info-tag">AI 3: <span id="chips-3">$10000</span> (<span id="cnt-3">0</span>)</div>
        <div class="hand" id="hand-3"></div>
    </div>
</div>

<script>
/* ================= 全局變數 ================= */
const SUITS = ['C','D','H','S']; 
const API_RANKS = {3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'0',11:'J',12:'Q',13:'K',14:'A',15:'2'};
// 為了視覺清爽，對手背面使用純色或簡單圖案，這裡沿用API背面
const BACK_IMG = "https://deckofcardsapi.com/static/img/back.png";

let players = [];
let currentTurn = 0;   
let lastPlay = null;   
let passCount = 0;     
let isRoundActive = false; 
let isFirstTurnOfGame = true;
let gameStake = 100;
let isGameRunning = false;
// MODIFIED: 新增遊戲模式變量
let gameMode = 'normal'; 
let exchangeCards = []; // 用於存儲交換的牌

// MODIFIED: 新增步步高規則相關變量
let roundPassed = {}; // 記錄每輪誰已經PASS過
let currentRoundMaxPlayer = 0; // 記錄當前輪次中出最大牌的玩家
let consecutivePassCount = 0; // 記錄連續PASS數

/* ================= 初始化 ================= */
function initPlayers() {
    players = Array(4).fill(0).map((_, i) => ({
        id: i,
        isHuman: i === 0,
        hand: [],
        chips: 10000,
        lastSearchIndex: 0
    }));
    updateInfoUI();
}

// MODIFIED: 添加遊戲模式選擇功能
function selectGameMode(mode) {
    gameMode = mode;
    // 更新按鈕樣式
    document.getElementById('mode-normal').classList.toggle('selected', mode === 'normal');
    document.getElementById('mode-exchange').classList.toggle('selected', mode === 'exchange');
}

function startGame(stake) {
    gameStake = stake;
    document.getElementById('modal-overlay').style.display = 'none';
    initPlayers();
    
    // MODIFIED: 根據遊戲模式啟動不同流程
    if (gameMode === 'exchange') {
        startExchangeRound();
    } else {
        startNewRound();
    }
}

// MODIFIED: 新增交換局流程
function startExchangeRound() {
    let deck = createDeck();
    shuffle(deck);

    players.forEach(p => { p.hand = []; p.lastSearchIndex = 0; });
    document.getElementById('center-play').innerHTML = '';

    // 發牌
    for(let i=0; i<13; i++) {
        for(let p=0; p<4; p++) {
            players[p].hand.push(deck.pop());
        }
    }
    players.forEach(p => sortHand(p.hand));

    isRoundActive = false;
    isFirstTurnOfGame = true;
    lastPlay = null;
    passCount = 0;

    // 渲染手牌，但隱藏按鈕
    renderAllHands();
    updateInfoUI();
    
    // 顯示交換按鈕
    document.getElementById('exchange-ui').style.display = 'flex';
    
    // 顯示提示
    showMsg("選擇0-3張牌準備交換", 3000);
}

// MODIFIED: 執行交換邏輯
function performExchange() {
    // 收集玩家選擇的交換牌
    exchangeCards = [];
    for (let i = 0; i < 4; i++) {
        const player = players[i];
        let selectedCards = [];
        
        // 人類玩家
        if (i === 0) {
            const selectedEls = document.querySelectorAll('#hand-0 .selected');
            selectedCards = Array.from(selectedEls).map(el => player.hand[parseInt(el.dataset.idx)]);
        } 
        // AI玩家
        else {
            // 隨機選擇0-3張牌
            const numToExchange = Math.floor(Math.random() * 4);
            const shuffledHand = [...player.hand];
            shuffle(shuffledHand);
            selectedCards = shuffledHand.slice(0, numToExchange);
        }
        
        // 記錄交換的牌
        exchangeCards.push({
            playerId: i,
            cards: selectedCards
        });
    }
    
    // 檢查玩家是否選擇了正確數量的牌 (0-3)
    const humanCards = exchangeCards[0].cards;
    if (humanCards.length > 3) {
        showMsg("請選擇0-3張牌", 2000);
        return;
    }
    
    // 開始交換動畫
    exchangeAnimation();
}

// MODIFIED: 交換牌動畫
function exchangeAnimation() {
    document.getElementById('exchange-ui').style.display = 'none';
    showMsg("交換牌中...", 2000);
    
    // 1. 將交換的牌放到中央區域
    const center = document.getElementById('center-play');
    center.innerHTML = '';
    
    let allExchangeCards = [];
    exchangeCards.forEach(exchange => {
        allExchangeCards = allExchangeCards.concat(exchange.cards);
    });
    
 // 2. 顯示所有交換的牌（背面）
allExchangeCards.forEach((card, i) => {
    const div = document.createElement('div');
    div.className = 'card';
    div.style.zIndex = i;
    div.style.transform = `translate(${Math.random()*100 - 50}px, ${Math.random()*100 - 50}px)`;
    // MODIFIED: 交換牌時顯示背面，而不是正面
    div.innerHTML = `<img src="${BACK_IMG}">`;
    center.appendChild(div);
});
    
    // 3. 動畫效果：牌飛向中心
    gsap.to('#center-play .card', {
        x: 0, y: 0, scale: 0.8,
        duration: 0.8, stagger: 0.05, ease: "power2.out",
        onComplete: () => {
            // 4. 洗牌動畫
            gsap.to('#center-play .card', {
                rotation: 360, duration: 1.5, 
                ease: "power1.inOut", repeat: 3,
                onComplete: () => {
                    // 5. 重新分發牌
                    shuffle(allExchangeCards);
                    
                    let startIndex = 0;
                    for (let i = 0; i < 4; i++) {
                        const numCards = exchangeCards[i].cards.length;
                        if (numCards > 0) {
                            const playerCards = allExchangeCards.slice(startIndex, startIndex + numCards);
                            startIndex += numCards;
                            
                            // 從玩家手牌中移除交換的牌
                            players[i].hand = players[i].hand.filter(card => 
                                !exchangeCards[i].cards.some(exCard => exCard.val === card.val)
                            );
                            
                            // 添加新的牌
                            players[i].hand = players[i].hand.concat(playerCards);
                            sortHand(players[i].hand);
                        }
                    }
                    
                    // 6. 渲染更新後的手牌
                    renderAllHands();
                    updateInfoUI();
                    
                    // 7. 開始正常遊戲流程
                    setTimeout(() => {
                        startNewRoundWithExchange();
                    }, 800);
                }
            });
        }
    });
}

// MODIFIED: 帶交換的正常遊戲流程
function startNewRoundWithExchange() {
    if(players.some(p => p.chips <= 0)) {
        gameOver();
        return;
    }

    isGameRunning = true;
    
    isRoundActive = false;
    isFirstTurnOfGame = true;
    lastPlay = null;
    passCount = 0;

    renderAllHands();
    updateInfoUI();

    if(checkDragon()) return; 

    determineFirstPlayer();
    checkTurn();
}

function startNewRound() {
    if(players.some(p => p.chips <= 0)) {
        gameOver();
        return;
    }

    isGameRunning = true;
    let deck = createDeck();
    shuffle(deck);

    players.forEach(p => { p.hand = []; p.lastSearchIndex = 0; });
    document.getElementById('center-play').innerHTML = '';

    for(let i=0; i<13; i++) {
        for(let p=0; p<4; p++) {
            players[p].hand.push(deck.pop());
        }
    }
    players.forEach(p => sortHand(p.hand));

    // 重置步步高規則相關狀態
    resetRoundState();
    
    renderAllHands();
    updateInfoUI();

    if(checkDragon()) return; 

    determineFirstPlayer();
    checkTurn();
}

function startNewRoundWithExchange() {
    if(players.some(p => p.chips <= 0)) {
        gameOver();
        return;
    }

    isGameRunning = true;
    
    // 重置步步高規則相關狀態
    resetRoundState();
    
    renderAllHands();
    updateInfoUI();

    if(checkDragon()) return; 

    determineFirstPlayer();
    checkTurn();
}

// 新增函數：重置輪次狀態
function resetRoundState() {
    isRoundActive = false;
    isFirstTurnOfGame = true;
    lastPlay = null;
    passCount = 0;
    
    // 重置步步高規則相關變量
    roundPassed = {};
    currentRoundMaxPlayer = 0;
    consecutivePassCount = 0;
}

function createDeck() {
    let d = [];
    for(let s=0; s<4; s++) {
        for(let r=3; r<=15; r++) {
            let apiR = API_RANKS[r];
            let apiS = SUITS[s].substring(0,1); 
            let img = `https://deckofcardsapi.com/static/img/${apiR}${apiS}.png`;
            if(r===10) img = `https://deckofcardsapi.com/static/img/0${apiS}.png`;
            d.push({
                rank: r, suit: s, 
                val: r*10 + s, 
                img: img, id: `${r}-${s}`
            });
        }
    }
    return d;
}

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

function sortHand(hand) {
    hand.sort((a,b) => a.val - b.val);
}

function determineFirstPlayer() {
    for(let i=0; i<4; i++) {
        if(players[i].hand.some(c => c.rank === 3 && c.suit === 0)) {
            currentTurn = i;
            break;
        }
    }
    showMsg(`由玩家 ${players[currentTurn].isHuman ? '你' : currentTurn} (3♣) 先手`);
}

/* ================= 核心邏輯 ================= */
function checkDragon() {
    for(let i=0; i<4; i++) {
        const p = players[i];
        const ranks = new Set(p.hand.map(c => c.rank));
        if(ranks.size === 13) {
            showMsg(`玩家 ${i} 一條龍獲勝！`);
            handleRoundEnd(i, true); 
            return true;
        }
    }
    return false;
}

function checkTurn() {
    if(!isGameRunning) return;
    document.querySelectorAll('.player').forEach(el => el.classList.remove('active'));
    document.getElementById(`player-${currentTurn}`).classList.add('active');

    document.querySelectorAll('.smart-btn').forEach(btn => btn.classList.remove('active-hint'));

    updateBtnState();

    if(players[currentTurn].isHuman) {
        showMsg(isRoundActive ? "輪到你了" : "自由出牌");
        players[0].lastSearchIndex = 0;
        // MODIFIED: 修復智慧選牌提示
        if(!isRoundActive && !isFirstTurnOfGame) {
            // 自由出牌階段，顯示所有可用牌型
            ['pair', 'straight', 'fullhouse', 'fourkind'].forEach(type => {
                const candidates = findCandidates(type);
                if(candidates.length > 0) {
                    document.getElementById(`smart-${type}`).classList.add('active-hint');
                }
            });
        } else {
            checkSmartHints();
        }
    } else {
        setTimeout(aiThink, 1500);
    }
}

function nextTurn() {
    if(players[currentTurn].hand.length === 0) {
        handleRoundEnd(currentTurn, false);
        return; 
    }
    
    // 找到下一個可以出牌的玩家
    let nextPlayer = (currentTurn + 1) % 4;
    let iterations = 0;
    
    // 最多檢查4個玩家
    while (iterations < 4) {
        // 如果下一位玩家已經PASS，跳過
        if (roundPassed[nextPlayer]) {
            nextPlayer = (nextPlayer + 1) % 4;
            iterations++;
            continue;
        }
        
        // 如果已經檢查完所有玩家，回到起始玩家
        if (nextPlayer === currentTurn) {
            break;
        }
        
        // 找到可以出牌的玩家
        currentTurn = nextPlayer;
        checkTurn();
        return;
    }
    
    // 修改：移除原 if (consecutivePassCount >= 3) 區塊，因為已移到 executePass()
    // 如果沒有其他玩家可以出牌，直接到下一個（但現在由 executePass 處理重置）
    currentTurn = (currentTurn + 1) % 4;
    checkTurn();
}

/* ================= 結算 ================= */
function handleRoundEnd(winnerIdx, isSpecialWin) {
    isGameRunning = false;
    showMsg(`贏家: ${players[winnerIdx].isHuman?'你':`AI ${winnerIdx}`}`);
    if(!isSpecialWin) confetti({ particleCount: 200, spread: 120, origin: { y: 0.6 } });

    let totalWin = 0;
    let multiplier = 1;
    let specialText = "";
    
    // 檢查特殊牌型
    if(lastPlay) {
        // 檢查是否包含2（非單張）
        if(lastPlay.count > 1) {
            const hasTwo = lastPlay.cards.some(card => card.rank === 2);
            if(hasTwo) {
                multiplier = 2;
                specialText = "大老二";
            }
        }
        
        // 檢查是否為鐵支
        if(lastPlay.type === 'fourkind') {
            multiplier = 2;
            specialText = "鐵支";
        }
        
        // 檢查是否為同花順（排除A-2-3-4-5）
        if(lastPlay.type === 'straightflush') {
            // 檢查是否為A-2-3-4-5
            const ranks = lastPlay.cards.map(c => c.rank);
            const isA2345 = (ranks[0] === 14 && ranks[1] === 2 && ranks[2] === 3 && ranks[3] === 4 && ranks[4] === 5);
            if(!isA2345) {
                multiplier = 2;
                specialText = "柳丁";
            }
        }
    }

    players.forEach(p => {
        if(p.id !== winnerIdx) {
            let count = p.hand.length;
            let cost = count * gameStake * multiplier; // 應用倍數
            if(count > 10 || isSpecialWin) cost *= 2;    
            
            p.chips -= cost;
            totalWin += cost;
            
            // 顯示特殊文字效果
            let msg = `-$${cost}`;
            if(multiplier > 1) {
                msg += ` (${specialText})`;
                // 添加特殊文字效果
                showPop(p.id, `${specialText}!`, '#ffeb3b');
            }
            showPop(p.id, msg, '#ff5252');
        }
    });

    players[winnerIdx].chips += totalWin;
    // 顯示特殊文字效果
    let winMsg = `+$${totalWin}`;
    if(multiplier > 1) {
        winMsg += ` (${specialText})`;
    }
    showPop(winnerIdx, winMsg, '#4caf50');
    
    updateInfoUI();

    if(players.some(p => p.chips <= 0)) {
        setTimeout(gameOver, 2500);
    } else {
        setTimeout(() => {
            if (gameMode === 'exchange') {
                startExchangeRound();
            } else {
                startNewRound();
            }
        }, 3000);
    }
}

function gameOver() {
    const overlay = document.getElementById('modal-overlay');
    const screen = document.getElementById('game-over-screen');
    const title = document.getElementById('go-title');
    const msg = document.getElementById('go-msg');
    
    document.getElementById('start-screen').style.display = 'none';
    overlay.style.display = 'flex';
    screen.style.display = 'block';

    const human = players[0];
    if(human.chips <= 0) {
        title.style.color = '#ef5350';
        title.textContent = "YOU LOSE";
        msg.textContent = "籌碼歸零，你破產了！";
    } else {
        title.style.color = '#ffd700';
        title.textContent = "YOU WIN";
        msg.textContent = `最終籌碼: $${human.chips}`;
    }
}

/* ================= 智慧選牌 ================= */
function findCandidates(targetType) {
    const hand = players[0].hand;
    const groups = {};
    hand.forEach(c => { if(!groups[c.rank]) groups[c.rank]=[]; groups[c.rank].push(c); });
    let candidates = [];

    if(targetType === 'pair') {
        candidates = Object.values(groups).filter(g => g.length >= 2).map(g => g.slice(0,2));
    } else if (targetType === 'fullhouse') {
        const threes = Object.values(groups).filter(g => g.length === 3);
        const pairs = Object.values(groups).filter(g => g.length >= 2);
        threes.forEach(t => {
           pairs.forEach(p => {
               if(p[0].rank !== t[0].rank) candidates.push([...t, p[0], p[1]]);
           });
        });
    } else if (targetType === 'fourkind') {
        const fours = Object.values(groups).filter(g => g.length === 4);
        fours.forEach(f => {
            hand.forEach(kicker => {
                if(kicker.rank !== f[0].rank) candidates.push([...f, kicker]);
            });
        });
    } else if (targetType === 'straight') {
        const unique = [];
        const seen = new Set();
        hand.forEach(c => { if(!seen.has(c.rank)) { seen.add(c.rank); unique.push(c); }});
        for(let i=0; i <= unique.length-5; i++) {
            const sub = unique.slice(i, i+5);
            let isSeq = true;
            for(let k=0; k<4; k++) if(sub[k+1].rank - sub[k].rank !== 1) isSeq = false;
            if(isSeq) candidates.push(sub);
        }
    }else if (targetType === 'straightflush') {
        // 找同花順
        const suits = {};
        hand.forEach(c => {
            if(!suits[c.suit]) suits[c.suit] = [];
            suits[c.suit].push(c);
        });
        
        // 檢查每個花色是否有同花順
        for(const suit in suits) {
            const sameSuitCards = suits[suit].sort((a,b) => a.rank - b.rank);
            if(sameSuitCards.length < 5) continue;
            
            for(let i=0; i <= sameSuitCards.length-5; i++) {
                const sub = sameSuitCards.slice(i, i+5);
                let isSeq = true;
                for(let k=0; k<4; k++) if(sub[k+1].rank - sub[k].rank !== 1) isSeq = false;
                
                // 排除A-2-3-4-5 (最小順子)
                const isA2345 = (sub[0].rank === 14 && sub[1].rank === 2 && sub[2].rank === 3 && sub[3].rank === 4 && sub[4].rank === 5);
                if(isSeq && !isA2345) {
                    candidates.push(sub);
                }
            }
        }
    }
    return candidates;
}

function checkSmartHints() {
    // 新增 'straightflush' 檢查
    ['pair', 'straight', 'fullhouse', 'fourkind', 'straightflush'].forEach(type => {
        const candidates = findCandidates(type);
        if(candidates.length === 0) return; 

        let hasPlayable = false;
        if(!isRoundActive) hasPlayable = true;
        else {
            const playable = candidates.filter(combo => validatePlayMatch(combo));
            if(playable.length > 0) hasPlayable = true;
        }

        if(hasPlayable) document.getElementById(`smart-${type}`).classList.add('active-hint');
    });
}

function autoSelect(targetType) {
    if(currentTurn !== 0) return;
    clearSelection();
    
    const candidates = findCandidates(targetType);
    if(candidates.length === 0) { showMsg("無此牌型"); return; }

    let validCandidates = isRoundActive 
        ? candidates.filter(combo => validatePlayMatch(combo))
        : candidates;

    if(isFirstTurnOfGame) validCandidates = validCandidates.filter(c => c.some(card => card.val === 30));

    if(validCandidates.length === 0) { showMsg("無法壓牌"); return; }

    let idx = players[0].lastSearchIndex % validCandidates.length;
    const targetCards = validCandidates[idx];
    players[0].lastSearchIndex++;

    targetCards.forEach(c => {
        const el = Array.from(document.querySelectorAll('#hand-0 .card')).find(e => parseInt(e.dataset.val) === c.val);
        if(el) el.classList.add('selected');
    });
    updateBtnState();
}

function clearSelection() {
    document.querySelectorAll('#hand-0 .card').forEach(el => el.classList.remove('selected'));
    updateBtnState();
}

/* ================= 出牌與驗證 ================= */
function humanPlay() {
    const handDiv = document.getElementById('hand-0');
    const selectedEls = handDiv.querySelectorAll('.selected');
    const cards = Array.from(selectedEls).map(el => players[0].hand[parseInt(el.dataset.idx)]);

    const result = validatePlay(cards);
    if(result.valid) {
        executePlay(0, cards, result.handInfo);
    } else {
        showMsg(result.msg);
        gsap.to('#hand-0', {x:10, yoyo:true, repeat:3, duration:0.05});
    }
}

function humanPass() {
    if(!isRoundActive) return;
    executePass(0);
}

function executePlay(pIdx, cards, handInfo) {
    const p = players[pIdx];
    p.hand = p.hand.filter(c => !cards.some(played => played.val === c.val));
    
    const center = document.getElementById('center-play');
    center.innerHTML = '';
    cards.forEach((c, i) => {
        const div = document.createElement('div');
        div.className = 'card';
        div.style.zIndex = i;
        // 遊戲過程中顯示正面給所有人看（包括其他玩家的出牌）
        const imgSrc = c.img;
        div.innerHTML = `<img src="${imgSrc}">`;
        center.appendChild(div);
    });

    if(handInfo.type !== 'single') showPop(pIdx, handInfo.type.toUpperCase());

    lastPlay = { pIdx, type: handInfo.type, score: handInfo.score, count: cards.length };
    isRoundActive = true;
    passCount = 0; 
    if(isFirstTurnOfGame) isFirstTurnOfGame = false;

    // MODIFIED: 步步高規則 - 重置連續PASS數並更新最大出牌玩家
    consecutivePassCount = 0;
    currentRoundMaxPlayer = pIdx; // 記錄當前最大出牌玩家

    renderAllHands();
    updateInfoUI(); 
    nextTurn();
}

function executePass(pIdx) {
    showPop(pIdx, "PASS", '#bdbdbd');
    passCount++;
    
    // 記錄該玩家在本輪已PASS
    roundPassed[pIdx] = true;
    
    // 增加連續PASS數
    consecutivePassCount++;
    
    // 修改：檢查PASS人數是否達3（即其他三人都PASS）
    const passedCount = Object.keys(roundPassed).length;
    if (passedCount >= 3) {  // 4玩家中3個PASS，剩餘一個是最大
        setTimeout(() => {
            // MODIFIED: 關鍵修復 - 正確重置遊戲狀態
            isRoundActive = false;
            isFirstTurnOfGame = false; // 不是首輪，但可以自由出牌
            lastPlay = null;
            document.getElementById('center-play').innerHTML = '';
            showMsg(`玩家 ${currentRoundMaxPlayer} 取得自由出牌權`);
            
            // 設置下一個輪次從最大出牌玩家開始
            currentTurn = currentRoundMaxPlayer;
            
            // 重置PASS狀態
            roundPassed = {};
            consecutivePassCount = 0;
            
            // 重新渲染並更新UI
            renderAllHands();
            updateBtnState();
            checkTurn();
        }, 800);
    } else {
        // 否則繼續輪到下一位玩家
        nextTurn();
    }
}

function validatePlayMatch(cards) {
    const info = getHandType(cards);
    if(!info) return false;
    if(cards.length !== lastPlay.count) return false; 
    if(cards.length === 5) return info.score > lastPlay.score;
    if(info.type !== lastPlay.type) return false;
    return info.score > lastPlay.score;
}

function validatePlay(cards) {
    if(cards.length === 0) return { valid: false, msg: "請選牌" };
    const handInfo = getHandType(cards);
    if(!handInfo) return { valid: false, msg: "牌型錯誤" };

    // MODIFIED: 處理首輪必須出3♣的規則
    if(isFirstTurnOfGame) {
        if(!cards.some(c => c.rank === 3 && c.suit === 0)) return { valid: false, msg: "需包含 3♣" };
    }

    // MODIFIED: 關鍵修復 - 如果不是isRoundActive，表示可以自由出牌
    if(!isRoundActive && !isFirstTurnOfGame) {
        return { valid: true, handInfo };
    }

    if(isRoundActive && lastPlay) {
        // 修改：加鐵支例外，允許5張鐵支壓任何張數
        if(cards.length !== lastPlay.count && !(cards.length === 5 && handInfo.type === 'fourkind')) return { valid: false, msg: "張數不符" };
        
        if(cards.length === 5) {
            // 特別處理：鐵支可以贏過任何5張牌型（已存在）
            if (handInfo.type === 'fourkind' && lastPlay.type !== 'fourkind') {
                return { valid: true, handInfo };
            }
            // 修改：如果張數不同但是鐵支，直接允許（壓<5張）
            else if (handInfo.type === 'fourkind' && cards.length !== lastPlay.count) {
                return { valid: true, handInfo };
            }
            // 同牌型比較分數
            else if (handInfo.type === lastPlay.type && handInfo.score > lastPlay.score) {
                return { valid: true, handInfo };
            }
            // 其他情況需要分數更高
            else if (handInfo.score > lastPlay.score) {
                return { valid: true, handInfo };
            }
            return { valid: false, msg: "牌不夠大" };
        } else {
            if(handInfo.type !== lastPlay.type) return { valid: false, msg: "牌型不符" };
            if(handInfo.score > lastPlay.score) return { valid: true, handInfo };
            return { valid: false, msg: "牌太小了" };
        }
    }
    return { valid: true, handInfo };
}

function getHandType(cards) {
    cards.sort((a,b) => a.rank - b.rank); 
    const len = cards.length;
    
    if(len === 1) return { type: 'single', score: cards[0].val };
    
    if(len === 2) {
        if(cards[0].rank === cards[1].rank) return { type: 'pair', score: cards[1].val }; 
        return null;
    }
    
    if(len === 5) {
        const counts = {};
        cards.forEach(c => counts[c.rank] = (counts[c.rank]||0)+1);
        const vals = Object.values(counts);
        const isFlush = cards.every(c => c.suit === cards[0].suit);
        
        let isStraight = false;
        let straightScore = 0;
        const r = cards.map(c=>c.rank);
        
        // MODIFIED: 修改順子判斷邏輯
        // 檢查A-2-3-4-5 (最小順子)
        if (r[0] === 14 && r[1] === 2 && r[2] === 3 && r[3] === 4 && r[4] === 5) {
            isStraight = true;
            // 使用特殊分數表示A-2-3-4-5順子，低於3-4-5-6-7
            straightScore = 100 + r[0] * 10 + r[0]; // 100 + 14*10 + 14 = 254
        }
        // 檢查2-3-4-5-6 (最大順子)
        else if (r[0] === 2 && r[1] === 3 && r[2] === 4 && r[3] === 5 && r[4] === 6) {
            isStraight = true;
            // 使用特殊分數表示2-3-4-5-6順子，高於A-2-3-4-5
            straightScore = 190 + r[4] * 10 + r[4]; // 190 + 6*10 + 6 = 256
        }
        // 檢查一般順子
        else if (r[4] - r[0] === 4 && new Set(r).size === 5) {
            isStraight = true;
            straightScore = 200 + r[4] * 10 + r[4];
        }
        
        // 檢查是否為同花順
        if(isStraight && isFlush) return { type: 'straightflush', score: 40000 + straightScore };
        
        // MODIFIED: 鐵支可以贏過單張、葫蘆、順子
        // 鐵支評分設置得很高，高於同花順和葫蘆
        if(vals.includes(4)) {
            const fourOfAKindRank = parseInt(Object.keys(counts).find(k => counts[k] === 4));
            return { type: 'fourkind', score: 45000 + fourOfAKindRank * 10 };
        }
        
        // 葫蘆
        if(vals.includes(3) && vals.includes(2)) {
            const threeRank = parseInt(Object.keys(counts).find(k => counts[k] === 3));
            return { type: 'fullhouse', score: 20000 + threeRank * 10 };
        }
        
        // 順子
        if(isStraight) {
            return { type: 'straight', score: 10000 + straightScore };
        }
    }
    return null;
}

/* ================= UI Utils ================= */
function renderAllHands() {
    players.forEach(p => {
        const div = document.getElementById(`hand-${p.id}`);
        div.innerHTML = '';
        p.hand.forEach((card, idx) => {
            const el = document.createElement('div');
            el.className = 'card';
            
            // MODIFIED: 添加灰色遮罩表示該輪無法出牌
            if (roundPassed[p.id] && !p.isHuman) {
                el.style.filter = 'grayscale(100%) brightness(0.7)';
                el.style.opacity = '0.5';
            }
            
            // 只有自己顯示牌面，其他顯示背面
            const imgSrc = p.isHuman ? card.img : BACK_IMG;
            el.innerHTML = `<img src="${imgSrc}">`;
            el.dataset.idx = idx;
            el.dataset.val = card.val;
            el.style.zIndex = idx; 

            if(p.isHuman) {
                el.onclick = () => { el.classList.toggle('selected'); updateBtnState(); };
            }
            div.appendChild(el);
        });
    });
}

function updateInfoUI() {
    // 更新底部欄 Human (Player 0)
    document.getElementById('my-chips').textContent = `$${players[0].chips}`;
    document.getElementById('my-cnt').textContent = players[0].hand.length;

    // 更新 AI 標籤
    for(let i=1; i<=3; i++) {
        document.getElementById(`chips-${i}`).textContent = `$${players[i].chips}`;
        document.getElementById(`cnt-${i}`).textContent = players[i].hand.length;
    }
}

function updateBtnState() {
    const selected = document.querySelectorAll('#hand-0 .selected');
    const playBtn = document.getElementById('btn-play');
    const passBtn = document.getElementById('btn-pass');

    if(currentTurn !== 0) {
        playBtn.disabled = true; passBtn.disabled = true; return;
    }
    playBtn.disabled = (selected.length === 0);
    passBtn.disabled = (isFirstTurnOfGame || !isRoundActive); 
}

function showMsg(txt, duration = 2000) {
    const box = document.getElementById('info-box');
    box.textContent = txt; box.style.display = 'block';
    setTimeout(() => box.style.display = 'none', duration);
}

function showPop(pIdx, text, color='#ffeb3b') {
    const p = document.getElementById(`player-${pIdx}`);
    const div = document.createElement('div');
    div.className = 'msg-pop';
    div.textContent = text;
    div.style.color = color;
    
    // 位置微調
    if(pIdx===0) div.style.top = '-80px';
    else div.style.top = '0px';

    p.appendChild(div);
    gsap.fromTo(div, {y:20, opacity:0}, {y:-20, opacity:1, duration:0.4});
    gsap.to(div, {opacity:0, duration:0.5, delay: 0.8, onComplete:()=>div.remove()});
}

/* ================= 加強版 AI ================= */
function getCombinations(arr, k) {
    // 產生所有 C(n,k) 組合（用來找五張牌型）
    const result = [];
    function helper(start, current) {
        if (current.length === k) {
            result.push([...current]);
            return;
        }
        for (let i = start; i < arr.length; i++) {
            current.push(arr[i]);
            helper(i + 1, current);
            current.pop();
        }
    }
    helper(0, []);
    return result;
}

// MODIFIED: 新增AI策略函數
function evaluateCardValue(card, playedCardsHistory) {
    // 根據歷史出牌評估卡片價值
    const historyCount = playedCardsHistory.filter(c => c.rank === card.rank).length;
    // 已經出現過的牌越多，價值越低
    return card.rank - historyCount;
}

function shouldBreakCombination(ai, hand, playedCardsHistory) {
    // 判斷是否應該拆掉組合出單張或兩張
    const groups = {};
    hand.forEach(c => { 
        if(!groups[c.rank]) groups[c.rank]=[];
        groups[c.rank].push(c); 
    });
    
    // 計算有多少組合
    const combinations = Object.values(groups).filter(g => g.length >= 3);
    if(combinations.length < 5) return false; // 手牌組合不多就不拆
    
    // 計算大牌比例
    const highCards = hand.filter(c => c.rank >= 13); // K, A, 2
    return highCards.length > hand.length * 0.4; // 大牌超過40%考慮拆牌
}

function aiThink() {
    const ai = players[currentTurn];
    let hand = [...ai.hand];
    hand.sort((a, b) => a.val - b.val); // 排序

    let possiblePlays = [];
    let playedCardsHistory = []; // 記錄歷史出牌

    // MODIFIED: 收集歷史出牌
    if(lastPlay && lastPlay.pIdx !== undefined) {
        // 這裡簡化處理，實際應用中應該維護完整的歷史記錄
        playedCardsHistory = players[lastPlay.pIdx].hand.filter(c => 
            !hand.some(h => h.val === c.val)
        );
    }

    // 單張（所有）
    hand.forEach(card => {
        const info = getHandType([card]);
        if (info) {
            // MODIFIED: 考慮歷史出牌評估卡片價值
            const value = evaluateCardValue(card, playedCardsHistory);
            possiblePlays.push({ cards: [card], info, size: 1, value });
        }
    });

    // 對子（找所有同 rank）
    for (let i = 0; i < hand.length - 1; i++) {
        if (hand[i].rank === hand[i + 1].rank) {
            const cards = [hand[i], hand[i + 1]];
            const info = getHandType(cards);
            if (info) {
                const value = evaluateCardValue(hand[i], playedCardsHistory) + 
                              evaluateCardValue(hand[i+1], playedCardsHistory);
                possiblePlays.push({ cards, info, size: 2, value });
            }
            i++; // 跳過
        }
    }

    // 五張：窮舉所有組合，找到合法牌型
    if (hand.length >= 5) {
        const combos = getCombinations(hand, 5);
        combos.forEach(combo => {
            // 每組組合再排序一次（確保 getHandType 正確判斷）
            const sortedCombo = [...combo].sort((a, b) => a.val - b.val);
            const info = getHandType(sortedCombo);
            if (info) {
                const value = combo.reduce((sum, card) => 
                    sum + evaluateCardValue(card, playedCardsHistory), 0);
                possiblePlays.push({ cards: combo, info, size: 5, value });
            }
        });
    }

// 決定能出的牌型
    let validPlays = possiblePlays;
    if (isRoundActive && lastPlay) {
        // 修改：必須同張數、同牌型、分數更大，或是鐵支例外
        validPlays = possiblePlays.filter(play =>
            (play.size === lastPlay.count &&
            play.info.type === lastPlay.type &&
            play.info.score > lastPlay.score) ||
            (play.size === 5 && play.info.type === 'fourkind')  // 鐵支可壓任何
        );
    }

    // 首輪強制含 3♣
    if (isFirstTurnOfGame) {
        validPlays = validPlays.filter(play =>
            play.cards.some(c => c.rank === 3 && c.suit === 0) // 假設 suit 0 是梅花
        );
    }

    if (validPlays.length > 0) {
        // MODIFIED: 更智能的出牌策略
        let bestPlay;
        
        // 如果是自由出牌階段，優先考慮保留大牌組合
        if (!isRoundActive) {
            // 檢查是否應該拆掉組合
            if (shouldBreakCombination(ai, hand, playedCardsHistory)) {
                // 選擇價值較低的單張或對子
                const smallPlays = validPlays.filter(p => p.size <= 2);
                if (smallPlays.length > 0) {
                    smallPlays.sort((a, b) => a.value - b.value);
                    bestPlay = smallPlays[0];
                }
            }
            
            // 默認策略：出最小的（保留大牌）
            if (!bestPlay) {
                validPlays.sort((a, b) => a.info.score - b.info.score);
                bestPlay = validPlays[0];
            }
        } else {
            // 壓牌階段：出最小的合法牌
            validPlays.sort((a, b) => a.info.score - b.info.score);
            bestPlay = validPlays[0];
        }

        // 特殊情況：如果有7且不是必須壓牌，考慮PASS
        if (isRoundActive && !isFirstTurnOfGame) {
            const hasSeven = hand.some(c => c.rank === 7);
            const isPlayingSeven = bestPlay.cards.some(c => c.rank === 7);
            
            // 如果有7但不是最佳選擇，有一定機率PASS
            if (hasSeven && !isPlayingSeven && Math.random() < 0.3) {
                executePass(currentTurn);
                return;
            }
        }

        // 用原物件出牌
        const toPlay = bestPlay.cards.map(c =>
            ai.hand.find(card => card.val === c.val && card.suit === c.suit && card.rank === c.rank)
        );
        executePlay(currentTurn, toPlay, bestPlay.info);
    } else {
        // 沒有合法牌可出，PASS
        executePass(currentTurn);
    }
}
</script>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('sw.js')   // 去掉前導 /
        .then(reg => console.log('SW registered: ', reg))
        .catch(err => console.log('SW registration failed: ', err));
    });
  }
</script>
</body>

</html>










